<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo添加字数统计、阅读时长]]></title>
    <url>%2F2018%2F06%2F21%2FHexo%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1%E3%80%81%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF%2F</url>
    <content type="text"><![CDATA[配置NexT 主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件 themes/next/_config.yml 中打开 wordcount 统计功能即可。如下所示：12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: true 修改完成主题配置文件后，启动服务预览：1hexo server 访问 http://localhost:4000/ 链接，如果出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件，查看 Hexo 插件：1hexo --debug 安装如果没有安装 hexo-wordcount 插件，先安装该插件：1npm i --save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下：1npm install hexo-wordcount@2 --save 安装完成后，重新执行启动服务预览就可以了。 编辑模板路径：xxx_blog/themes/next/layout/_macro/post.swig 修改【字数统计】，找到如下代码后，改成如下样子：123&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; 同理，我们修改【阅读时长】，修改后如下：123&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 修改完成后，重新执行启动服务预览就可以了。修改后，效果如下图所示：修改完成后，重新执行启动服务预览就可以了。修改后，效果如下图所示：]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下docker配置加速器]]></title>
    <url>%2F2018%2F06%2F20%2FLinux%E4%B8%8Bdocker%E9%85%8D%E7%BD%AE%E5%8A%A0%E9%80%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[直接下载Docker镜像时，由于种种原因，经常下载失败，即使连接成功也是很慢,目前我知道可以提升速度的办法：DaoCloud 提供Docker Hub Mirror服务,用户可以进入Docker Hub Mirror注册入口注册（https://account.daocloud.io/signin）。在进入控制台页面后直接点击 启动你的加速器后，您即可得到一个Mirror的地址，将该地址配置在Docker Daemon的启动脚本中，重启Docker Daemon即可使得Docker Hub Mirror配置生效。 注册登录之后，点击加速器： 然后会得到一个Mirror的地址，将该地址配置在Docker Daemon的启动脚本中，重启Docker Daemon即可使得Docker Hub Mirror配置生效，换句话说，把这个获取的地址复制到要加速的服务器上执行一次，然后重启docker，就ok。 docker加速1234root@ubuntu:~# curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://4e70ba5d.m.daocloud.io root@ubuntu:~# cat /etc/docker/daemon.json &#123;"registry-mirrors": ["http://4e70ba5d.m.daocloud.io"]&#125; root@ubuntu:~# 重启docker服务1root@ubuntu:~# service docker restart 遇到的坑 *或许你会遇到这样的情况，在重启docker的时候发现因为配置的原因导致无法重启docker，这个时候执行cat /etc/docker/daemon.json，你会看到这样的结果：12root@ubuntu:~# cat /etc/docker/daemon.json &#123;"registry-mirrors": ["http://4e70ba5d.m.daocloud.io"],&#125; //这里的逗号有问题 去掉,后再次启动便成功！]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 - centos 7.2 /var/run/php-fpm/php-fpm.sock不存在]]></title>
    <url>%2F2018%2F06%2F20%2F%E6%90%AD%E5%BB%BALnmp%E7%8E%AF%E5%A2%83%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABphp%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Linux初学者，如有不对请多指点…0-0 在搭建Lnmp环境的时候可能会遇到这么一个问题，发现nginx安装好之后只能解析html文件的代码，却不能解析php文件的代码，这个时候可能出现的情况有两种，第一种是看php、php-fpm是否有装完成和是否启动；第二种情况就是下面的方案，跟系统的关系，nginx的配置有所不同。在nginx中配置重写规则中，有这么一句话： 1fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock 可是在centos7.2中，这个路径没有这个文件，只有一个php-fpm.pid文件，那么上面这个文件在哪里？123[root@izwz9a3uv2157di5ogaaytz sites-enabled]# cd /var/run/php-fpm/[root@izwz9a3uv2157di5ogaaytz php-fpm]# lsphp-fpm.pid 用find / -name &quot;*php*.sock&quot;找一下sock文件的位置，如果没找到的话就是没配置Unix Socket，只能访问TCP端口，可以为改为fastcgi_pass 127.0.0.1:9000 正确的配置：123456789101112location ~ \.php$ &#123; try_files $uri =404; fastcgi_split_path_info ^(.+\.php)(/.+)$; #fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock; //原来的 fastcgi_pass 127.0.0.1:9000; //更改之后 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $uri; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_index index.php; include fastcgi_params; &#125; CentOS7yum安装PHP7.2 12345678910yum -y remove php* //如果之前已经安装我们先卸载一下//由于linux的yum源不存在php7.x，所以我们要更改yum源rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm //yum 安装php72w和各种拓展，选自己需要的即可yum -y install php72w php72w-cli php72w-common php72w-devel php72w-embedded php72w-fpm php72w-gd php72w-mbstring php72w-mysqlnd php72w-opcache php72w-pdo php72w-xml]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习-part.04]]></title>
    <url>%2F2018%2F05%2F25%2FJava%E5%AD%A6%E4%B9%A0-part-04%2F</url>
    <content type="text"><![CDATA[java中的继承1、继承的概念： 继承是类与类的一种关系，是一中 &quot;is a&quot;的关系。 注：java中的继承是单继承2、继承的好处 子类拥有父类的所有的属性和方法，但是父类中的private修饰符无效 实现代码复用 eg：生活有要是有个好爹，就可以少奋斗几年;如果继承了父亲的权力，那就是官二代3、语法1234class 子类 extends 父类 例：class Dog extends Animal&#123; ....&#125; 12345678910111213141516171819202122232425262728293031323334353637//父类package com.imooc;//重庆人public class ChongQing &#123; String area = "西南地区"; // 地区 String love = "爱吃辣"; //喜好 String beatiWoman = "美女多"; //美女多 double population = 30000000;//人口 public void work() &#123; System.out.println("工作使我快乐！"); &#125; public void shoping() &#123; System.out.println("重庆人是喜欢购物的"); &#125;&#125;//子类package com.imooc;public class Xiexiang extends ChongQing &#123; public void getChongqing() &#123; System.out.print(area + "有个地方叫重庆，那里的人"+love+",而且" + beatiWoman + ",他们是很喜欢工作的，时常都会说：" ); work(); &#125; public static void main(String[] args) &#123; new Xiexiang().getChongqing(); &#125;&#125;//运行结果西南地区有个地方叫重庆，那里的人爱吃辣,而且美女多,他们是很喜欢工作的，时常都会说：工作使我快乐！ 方法的重写1、概念：如果子类对继承父类的方法不满意，是可以重写父类继承的方法的，当调用方法时会优先调用子类的方法。2、语法规则 语法规则 返回值类型 参数类型及个数都要与父类继承的方法相同，才叫方法的重写。 final关键字概念：使用final关键字做标识有&quot;最终的&quot;含义。final可以修饰类、方法、属性和变量 final修饰类，则该类不允许被继承 final修饰方法，则该方法不允许被覆盖（重写） final修饰属性，则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或是构造方法中赋值（但只能选其一）[就是属性只能赋值一次，不管是构造方法还是main方法都无法再次进行赋值] final修饰变量，则该变量的值只能赋一次值，即为常量。 super关键字super关键字：在对象的内部使用，可以代表父类对象。 访问父类的属性： super.love 访问父类的方法： super.work()1234567891011121314151617package com.imooc;public class Xiexiang extends ChongQing &#123; public void work() &#123; System.out.println("被重构之后的输出"); &#125; public void getChongqing() &#123; System.out.print(super.area + "有个地方叫重庆，那里的人"+super.love+",而且" + super.beatiWoman + ",他们是很喜欢工作的，时常都会说：" ); super.work(); //work方法被重写，使用super关键字后指向的是使用的是父类的work方法 work(); //这种写法默认是重写后的方法 &#125; public static void main(String[] args) &#123; new Xiexiang().getChongqing(); &#125;&#125; super的应用 如果子类的构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参的构造方法。 如果显示的调用构造方法，必须在子类的构造方法的第一行。 如果子类构造方法中既没有显示调用父类的构造方法，而父类又没有无参的构造方法，则会编译出错。 Object类object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类默认继承Object类。object类中的方法，适合所有的子类。 常用的方法：1、toString() 方法 返回值：字符串直接输出对象只能是返回哈希码生成的一个对象的内存地址，重写toString()方法能够清晰展现对象的属性值。 2、equals()方法 返回值：bool比较的是对象的引用是否指向同一块内存地址一般情况下比较两个对象时比较他的值是否一致，所以要进行重写。 多态 **概念：对象的多种形态1、引用的多态 父类的引用可以指向本类的对象 父类的引用可以指向子类的对象 eg:Dog类extends Animal类 Animal obj1 = new Animal(); Animal obj2 = new Dog(); //父类的引用是可以指向子类对象的 //Dog obj3 = new Animal(); //X 这种就是错误的 2、方法多态创建本类对象时，调用的方法为本类的方法创建子类对象时，调用的方法为子类重写的方法或者继承的方法。（也就是说，子类里面非继承和重写的方法，是不能调用的） 多态中的引用类型转换1、向上类型转换（隐式/自动类型转换），是小类型到大类型的转换；2、向下类型转换（强制类型转换），是大类型到小类型；3、instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。 123456789101112131415161718package com.imooc;public class convertType &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); Animal animal = dog; //自动类型提升，向上类型转换 Dog dog2 = (Dog)animal; //强制类型转换 向下类型转换 [存在风险] Cat cat = (Cat)animal; //风险点：编译器不会报错，但是运行时提示没有办法进行转换，Cat类型与Dog类型不一致 //上面的代码都不严谨，可以用到instanceof做检测 if(animal instanceof Cat) &#123; //避免类型转换的安全性问题 Cat cat = (Cat)animal; &#125;else &#123; System.out.println("无法进行类型转换"); &#125; &#125;&#125; 抽象类 **1、语法定义：抽象类前使用abstract关键字修饰，则该类为抽象类。 2、应用场景： 在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法； 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。 3、作用 *限制规定子类必须实现某些方法，但是不关注实现细节。 4、使用规则 abstract定义抽象类 abstract定义抽象方法，只有声明，不需要实现 包含抽象方法的类是抽象类 抽象类中可以包含普通的方法，也可以没有抽象方法 抽象类不能直接创建，可以定义引用变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.abstracttest;//图形抽象类public abstract class Mould &#123; //面积的实现 public abstract double area(double chang,double kuan); //周长的实现 public abstract double girth(double chang,double kuan);&#125;package com.abstracttest;//矩形public class Rectangle extends Mould &#123; @Override //矩形面积的计算 public double area(double chang, double kuan) &#123; // TODO Auto-generated method stub double newArea = chang * kuan; //长*宽 return newArea; &#125; @Override //矩形的周长 public double girth(double chang, double kuan) &#123; // TODO Auto-generated method stub double newGirth = 2*chang + 2*kuan; //2*长+2*宽 return newGirth; &#125;&#125;package com.abstracttest;//调用方public class init &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Mould mould = new Rectangle(); //父类引用指向子类对象 double newArea = mould.area(150, 145.55); //求面积 double newGirth = mould.girth(150, 145.55); //求周长 System.out.println("面积为：" + newArea); System.out.println("周长为：" + newGirth); &#125;&#125; 接口 **1、概述类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法。具有相同的功能，却不是同一个类的情况下，就可以使用接口2、接口的定义和类定义不同，定义接口不再使用class关键字，而是使用interface关键字。3、接口定义的基本语法12345public interface [abstract] 接口名 [extends 父接口1，父接口2 ...] //可以多继承&#123; //零到多个常量定义 ... //零到多个抽象方法的定义 ...&#125; 接口就是用来被继承、被实现的，修饰符一般建议用public注意：不能使用private和protected修饰接口4、接口的定义常量接口中的属性是常量，即使定义时不添加， public static final修饰符，系统也会自动加上。 方法接口中的方法只能是抽象方法，总是使用，即使定义时不添加public abstract修饰符，系统也会自动加上。 5、使用接口 （1）、一个类可以实现一个或者多个接口，实现接口使用implements关键字。java中一个类只能继承一个父类，是不够灵活的，通过实现多个接口可以做补充。 继承父类实现接口的语法为：1234567[修饰符] class 类名 extends 父类 implements 接口1，接口2 ...&#123; 类体部分 //1、如果继承了抽象类，需要实现继承的抽象方法； //2、如果遵守了接口，要实现接口中的抽象方法。 //**继承的抽象类中的方法和接口中的抽象方法都必须先实现。&#125; 注意：如果要继承父类，继承父类必须在实现接口之前。 根据下图实现接口实例： 实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182【Telphone.java】package com.phone;//电话抽象类public abstract class TelPhone &#123; //具有发短信功能 public abstract void sendMessage(); //具有打电话功能 public abstract void call();&#125;【IPlayGame.java】package com.phone;//游戏机 接口public abstract interface IPlayGame &#123; //具有玩游戏的功能 public abstract void playGame();&#125;【CellPhone.java】package com.phone;//以前的手机public class CellPhone extends TelPhone &#123; @Override //必须实现发短信功能 public void sendMessage() &#123; // TODO Auto-generated method stub System.out.println("老电话是具有发短信的功能"); &#125; @Override //必须实现打电话功能 public void call() &#123; // TODO Auto-generated method stub System.out.println("老电话是具有打电话的功能"); &#125;&#125;【SmartPhone.java】package com.phone;//现在的智能机public class SmartPhone extends TelPhone implements IPlayGame &#123; @Override //智能机具有发短信 public void sendMessage() &#123; // TODO Auto-generated method stub System.out.println("新电话是具有发短信的功能"); &#125; @Override //智能机具有打电话 public void call() &#123; // TODO Auto-generated method stub System.out.println("新电话是具有打电话的功能"); &#125; @Override //智能机还具有玩游戏 public void playGame() &#123; System.out.println("新电话还具有游戏的功能"); &#125;&#125;【init.java】 //出口-运行的地方package com.phone;public class init &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TelPhone tel1 = new CellPhone(); tel1.call(); tel1.sendMessage(); TelPhone tel2 = new SmartPhone(); tel2.call(); tel2.sendMessage(); SmartPhone tel3 = new SmartPhone(); tel3.playGame(); &#125;&#125; （2）、接口在使用过程当中，还经常与匿名内部类配合使用匿名内部类就是没有名字的内部类，多用于关注实现而不关注实现类的名称。 语法格式：12345Interface i = new Interface()&#123; public void method()&#123; System.out.println("匿名内部类实现接口的方式"); &#125;&#125; 实例：1234567891011121314151617181920212223242526272829303132333435363738package com.phone;public class init &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TelPhone tel1 = new CellPhone(); tel1.call(); tel1.sendMessage(); TelPhone tel2 = new SmartPhone(); tel2.call(); tel2.sendMessage(); SmartPhone tel3 = new SmartPhone(); tel3.playGame(); //匿名内部类的使用 如下两种方式 //语法第一种 IPlayGame pg = new IPlayGame() &#123; @Override public void playGame() &#123; // TODO Auto-generated method stub System.out.println("这是匿名内部类的方式实现接口"); &#125; &#125;; pg.playGame(); //语法第二种 new IPlayGame() &#123; @Override public void playGame() &#123; // TODO Auto-generated method stub System.out.println("这是匿名内部类的方式实现接口2"); &#125; &#125;.playGame(); &#125;&#125; ……..后面的内容更精彩………]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习-part.03]]></title>
    <url>%2F2018%2F05%2F23%2FJava%E5%AD%A6%E4%B9%A0-part-03%2F</url>
    <content type="text"><![CDATA[面向对象三大特性 封装、继承、多态 封装1、概念：将类的某些信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。 2、好处： 只能通过规定的方法访问数据 隐藏类的实例细节，方便修改和实现 3、实现步骤： 修改属性的可见性-设为private 创建setter/getter方法-用户属性的读写 在setter/getter方法中加入属性控制语句-对属性值的合法性进行判断12345678910111213141516171819202122package imooc;public class thisMacbook &#123; private float screen; //防止直接修改属性 private String color; private int cpu; public void setScrenn(float newScreen) &#123; //通过方法来修改属性 screen = newScreen; &#125; public float getScreen()&#123; //通过方法得到属性 return screen; &#125;&#125; //调用封装方法 thisMacbook macbook = new thisMacbook(); macbook.setScrenn(4.5f); float screen = macbook.getScreen(); System.out.println("macbook的屏幕大小为：" + screen); java中的包1、包的作用 管理java文件 解决同名文件冲突2、定义包：package包名 注：必须放在java源程序的第一行 包名间可以使用”.”号隔开 eg：com.zhubajie.MyClass3、包的使用 可以用过import关键字，在某个文件使用其他文件中的类。1import com.zhubajie.muisc.MyClass 在同一个包下面的所有类都是默认自动加载了的，标准的做法是使用import引入需要的类，当然也可以使用import引入其他包中的类。 java中的访问修饰符 访问修饰符 本类 同包 子类 其他 private * 默认 * * protected * * * public * * * * java中的this关键字1、this关键字代表当前对象 this.属性 操作当前对象的属性 this.方法 调用当前对象的方法 2、封装对象的属性的时候，经常会使用this关键字12345678910111213141516171819202122package com.zhubajie;public class ThisCar &#123; private String name; private String color; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printColor() &#123; System.out.println("车子的颜色是：" + this.getColor()); &#125;&#125; java中的内部类 **不得不说这里肯定是与php比较大的区别所在之处了，java支持在自己类里面再写一个类，具体来看一下：内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。 内部类作用 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类 内部类的方法可以直接访问外部类的所有数据，包括私有的数据 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便 内部类种类 成员内部类 静态内部类 方法内部类 匿名内部类 内部类及调用示例：1234567891011121314151617181920212223package com.imooc;//内部类示例public class InnerClass &#123; //内部类 (在类的里面再创建一个类) public class Inner&#123; //内部类中的方法体 public void print() &#123; System.out.println("内部类中的方法执行了!"); &#125; &#125; //怎么调用内部类中的方法 （这里需要多注意下） public static void main(String[] args) &#123; //先创建一个外部类对象 InnerClass innerClassObj = new InnerClass(); //再创建内部类对象 Inner innerObj = innerClassObj.new Inner(); //再调用内部类的方法 innerObj.print(); &#125;&#125; ||内部类中最常见的就是成员内部类，也称为普通内部类。我们来看如下代码：12345678910111213141516171819202122232425262728package com.imooc;//内部类示例public class outer &#123; private int a = 99; //外部成员私有属性 //内部类 (在类的里面再创建一个类) public class Inner&#123; int b = 2; //内部类成员属性 //内部类中的方法体 public void print() &#123; System.out.println("访问外部类中的a：" + a); //调用外部成员方法1 System.out.println("访问外部类中的a：" + outer.this.a); //调用外部成员方法2 System.out.println("访问内部成员中的b：" + b); &#125; &#125; //怎么调用内部类中的方法 （这里需要多注意下） public static void main(String[] args) &#123; //先创建一个外部类对象 outer auterObj = new outer(); //再创建内部类对象 Inner innerObj = auterObj.new Inner(); //再调用内部类的方法 innerObj.print(); &#125;&#125; 从上面的代码中我们可以看到，成员内部类的使用方法： 1、 Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等； 2、 Inner 类中定义的 print() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性a; 3、 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( ); 4、 编译上面的程序后，会发现产生了两个 .class 文件(在项目下的bin目录下) Outer$Inner.class Outer.class 其中，第二个是外部类的 .class 文件，第一个是内部类的 .class 文件，即成员内部类的 .class 文件总是这样：外部类名$内部类名.class。 ||重点提示： 1、外部类是不能直接使用内部类的成员和方法滴，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。12Inner innerObj = new outer().new Inner();innerObj.print(); 2、如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字。1System.out.println("访问外部类中的a：" + outer.this.a); //调用外部成员方法2 java中静态内部类静态内部类是 static修饰的内部类，这种内部类的特点是： 1、 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问； 2、 如果外部类的静态成员与内部类的成员名称相同，可通过类名.静态成员访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过成员名直接调用外部类的静态成员； 3、 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.imooc;public class StaticInner &#123; private String name = "xiexiang"; //外部类非静态成员 private static int age = 18; //外部类静态成员 public static class Inner&#123; private static int age = 19; //内部类成员 public void print() &#123; System.out.println("访问外部的非静态成员：" + new StaticInner().name); //new 外部类().成员 System.out.println("外部静态成员age=" + StaticInner.age); //同名情况下访问外部类成员 System.out.println("内部静态成员age=" + age); //内部成员的访问方式 Inner innerObj = new Inner(); System.out.println("最大值为：" + innerObj.getMax() ); //内部类间的非静态方法方法调用 System.out.println("最小值为：" + getMin()); //内部类间的静态方法方法调用 &#125; // 非静态方法 public int getMax() &#123; int scores[] = &#123;33,55,56,74&#125;; int max = scores[0]; for(int i=0; i&lt;scores.length;i++) &#123; if(scores[i] &gt; max) max = scores[i]; &#125; return max; &#125; //静态方法 public static int getMin() &#123; int scores[] = &#123;12,35,66,34,33&#125;; int min = scores[0]; for(int i=0; i&lt;scores.length;i++) &#123; if(scores[i] &lt; min) min = scores[i]; &#125; return min; &#125; &#125; //主入口 public static void main(String[] args) &#123; Inner innerObj = new Inner(); //实例化内部静态类可以直接new innerObj.print(); &#125;&#125;访问外部的非静态成员：xiexiang外部静态成员age=18内部静态成员age=19最大值为：74最小值为：12 java中的方法内部类学到这里，我觉得java即严谨又灵活，上面讲到类中含有类就算了，居然方法中还会含有类，厉害！继续往下看。。概念：方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法内部可见，即只在该方法内部可以使用。1234567891011121314151617181920212223package com.imooc;public class functionInnerClass &#123; public void show() &#123; String name = "xiexiang"; int age = 18; class NInner &#123; //方法内部类不能使用访问控制符和 static 修饰符 int sex = 1; public void print() &#123; String xb = ""; if(sex == 1) xb = "男"; System.out.println(name + "的年龄为" + age+ ",性别是：" + xb); //方法内部类只在该方法的内部可见，也只能使用方法中的成员 &#125; &#125; NInner mi = new NInner(); // 方法体中要实例化内部类，不然不会调用 mi.print(); //调用了方法内部类的方法 &#125; public static void main(String[] args) &#123; functionInnerClass io = new functionInnerClass(); io.show(); &#125;&#125; ||特别注意 由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。 ……..后面的内容更精彩………]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习-part.02]]></title>
    <url>%2F2018%2F05%2F23%2FJava%E5%AD%A6%E4%B9%A0-part-02%2F</url>
    <content type="text"><![CDATA[java的面向对象万物皆为对象，客观存在的事物皆为对象。类是模子，确定对象将会拥有的特征（属性）和行为（方法）类的特点： 类是对象的类型 具有相同属性和方法的一组对象的集合属性–对象具有的各种特征每个对象的每个属性都拥有特定值eg:比如一个手机具有屏幕大小、手机尺寸、颜色、价格等特征（属性）方法–对象执行的操作eg：比如一个手机具有打电话、发短信、安装软件等功能（方法） 下面以一个汽车为类做的例子：1234567891011121314151617181920212223242526272829package imooc;public class thisCar &#123; float length; float wide; String color; double money; /** * 获取车身长度 * @return */ public float getLeangth() &#123; return this.length; &#125; /** * 获取宽度 * @return */ public float getWide() &#123; return this.wide; &#125; /** * 获取车身颜色 * @return */ public String getColor() &#123; return this.color; &#125;&#125; 构造方法 使用new+构造方法，创建一个新的对象 构造方法是定义在java类中的一个用来初始化对象的方法，构造方法与类同名且没有返回值。123public 构造方法名[与类名一致] （）&#123; //没有返回值的与当前类名一样，参数可有可无 //初始化代码，在调用这个类时自动调用&#125; java中的static使用大家都知道，我们可以基于一个类创建多个该类的对象，每个对象都拥有自己的成员，互相独立。然而在某些时候，我们更希望该类所有的对象共享同一个成员。此时就是 static 大显身手的时候了！ Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问~~ 使用 static 可以修饰变量、方法和代码块。12345678910111213141516171819package imooc;public class staticTest &#123; static String name = "xiexaing"; static int scores[] = &#123;78,56,88,66,98&#125;; public static void main(String[] args) &#123; int max = staticTest.getTheMaxScore(scores); //调用静态属性和静态方法 System.out.println(name + "的班级中分数最高的是：" + max); //调用静态属性 &#125; // 获取分数的最大值 static public int getTheMaxScore(int scores[]) &#123; int max = scores[0]; for(int i=0;i&lt;scores.length;i++) &#123; if(scores[i] &gt; max) max = scores[i]; &#125; return max; &#125;&#125; 注意：静态成语属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收。 需要注意：1、 静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。如：1234567891011package imooc;public class staticTest2 &#123; String name = "xiexiang"; static int age = 18; public static void proint() &#123; System.out.println("您的名字：" + name); //报错x，静态方法中不能直接调用非静态成员，可以通过创建类的对象再开访问非静态成员 System.out.println("您的年龄：" + age); //可以直接调用 &#125;&#125; 2、 在普通成员方法中，则可以直接访问同类的非静态变量和静态变量，如下所示：1234567891011package imooc;public class staticTest2 &#123; String name = "xiexiang"; static int age = 18; public void proint() &#123; System.out.println("您的名字：" + name); //可以直接调用 System.out.println("您的年龄：" + age); //可以直接调用 &#125;&#125; 3、静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。如：12345678910111213141516171819202122package imooc;public class staticTest2 &#123; String name = "xiexiang"; static int age = 18; //非静态方法 public void print() &#123; System.out.println("您的名字：" + name); System.out.println("您的年龄：" + age); &#125; //静态方法 public static void show() &#123; System.out.println("这是静态方法可以直接调用"); &#125; //调用方++ public static void myTest() &#123; staticTest2 function = new staticTest2(); function.print(); //print方法需要实例化后再调用 show(); //show方法就可以直接调用 &#125;&#125; java中的static的使用之静态初始化块java中可以通过初始化块进行数据赋值。如：12345678package imooc;public class staticPiece &#123; String name; &#123; name = "xiexiang"; &#125;&#125; 在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。&amp;需要特别注意：静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。12345678910111213141516package imooc;public class staticPiece &#123; String name; static int age; &#123; name = "xiexiang"; &#125; static &#123; age = 18; &#125; public static void main(String[] args) &#123; staticPiece function = new staticPiece(); System.out.println(function.name+"的年龄为："+ age +"岁"); &#125;&#125; ……..后面的内容更精彩………]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习-part.01]]></title>
    <url>%2F2018%2F05%2F23%2FJava%E5%AD%A6%E4%B9%A0-part-01%2F</url>
    <content type="text"><![CDATA[java中的数据类型java语言是一种强类型语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型。 Java 中有两类数据类型：在 Java 的领域里，基本数据类型变量存的是数据本身，而引用类型变量存的是保存数据的空间地址。说白了，基本数据类型变量里存储的是直接放在抽屉里的东西，而引用数据类型变量里存储的是这个抽屉的钥匙，钥匙和抽屉一一对应。常用的基本数据类型有：注意：String是一种常见的引用数据类型，用来表示字符串。在程序开发中，很多操作都要使用字符串来完成，例如系统中的用户名、密码、电子邮箱等。float类型在赋值的时候后天添加字母f，float height = 175.2f。 java变量的定义1、变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 myAge2、变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 stuName 保存“学生姓名”信息PS： Java 变量名的长度没有限制，但 Java 语言是区分大小写的，所以 price 和 Price 是两个完全不同的变量哦！语法：变量类型 变量名 = 值;eg：String name = “xiexiang”; java常量的应用所谓常量，我们可以理解为是一种特殊的变量，它的值被设定后，在程序运行过程中不允许改变。语法： final 常量类型 常量名 = 值； //常量一般为大写字符关键词：final;eg：final String LOVE = “forever”; java中的数组语法：数据类型[] 数组名； 或者 数据类型 数组名[];数组的几种定义方式： double height[] = {175.2,168.4,232.4}; int[] scores = {12,33,45,132};还有种方式在是特定场合用的：int[] scores = new int[5]; //定义一个数组的长度为5 再赋值：scores[0] = 89;scores[1] = 79;… java中数组的遍历1234567891011//一维数组 String[] arrs = &#123;"rerew","ww4eqw","222"&#125;; //for的方式 for(int i=0;i&lt;arrs.length;i++) &#123; System.out.println(arrs[i]); &#125; //foreach方式 for(String arr:arrs) &#123; System.out.println(arr); &#125; 123456789 //二维数组遍历String[][] names = &#123;&#123;"xiexiang","xiangqian"&#125;,&#123;"make","diea","hello","23423"&#125;&#125;;//使用for进行二重循环for(int i=0;i&lt;names.length;i++) &#123; for(int j=0;j&lt;names[i].length;j++) &#123; System.out.println(names[i][j]); &#125;&#125; java中的方法语法： 访问修饰符 返回值类型 方法名（参数列表）{ 方法体 }其中：1、访问修饰符：方法允许被访问的权限范围， 可以是 public、protected、private 甚至可以省略 ，其中 public 表示该方法可以被其他任何代码调用。2、 返回值类型：方法返回值的类型，如果方法不返回任何值，则返回值类型指定为 void ；如果方法具有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。3、 方法名：定义的方法的名字，必须使用合法的标识符。4、 参数列表：传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。根据方法是否带参、是否带返回值，可将方法分为四类： Ø 无参无返回值方法 Ø 无参带返回值方法 Ø 带参无返回值方法 Ø 带参带返回值方法12345678910111213public class HelloWorld &#123; //定义了一个方法名为 print 的方法，实现输出信息功能 public void print() &#123; System.out.println("Hello World"); &#125; public static void main(String[] args)&#123; //在 main 方法中调用 print 方法 HelloWorld test=new HelloWorld(); test.print(); &#125;&#125; java中方法的重载定义：如果同一个类中包含了两个或两个以上方法名相同、方法参数的个数、顺序或类型不同的方法，则称为方法的重载，也可称该方法被重载了。当调用被重载的方法时， Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行。 &amp;判断方法重载的依据： 1、 必须是在同一个类中 2、 方法名相同 3、 方法参数的个数、顺序或类型不同 4、 与方法的修饰符或返回值没有关系 章节练习题需求：输入3个班级各4个学生的成绩，并在每个班级之后输出每个班级的成绩之和和平均成绩。1234567891011121314151617181920212223package imooc;import java.util.Scanner; //调用java的输入包public class stu &#123; public static void main(String[] args) &#123; int classNum = 3; //班级数量 int stuNum = 4; //每个班级学生数量 double sum = 0; //每个班级学生成绩之和 double avg = 0; //每个班级的平均成绩 Scanner input = new Scanner(System.in); //创建scanner对象 for(int i=1;i&lt;=classNum;i++) &#123; sum = 0; System.out.println("*****请输入第"+i+"个班级的成绩情况*****"); for(int j=1;j&lt;=stuNum;j++) &#123; System.out.println("请输入第"+j+"个学生的成绩："); double score = input.nextDouble(); // 获取输入成绩 sum+=score; &#125; avg = sum/stuNum; System.out.println("第个班的总成绩之和为："+sum+";平均成绩为："+avg); &#125; &#125;&#125; ……..后面的内容更精彩………]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泸沽湖-女儿国之行]]></title>
    <url>%2F2018%2F05%2F14%2F%E6%B3%B8%E6%B2%BD%E6%B9%96-%E5%A5%B3%E5%84%BF%E5%9B%BD%E4%B9%8B%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[来到泸沽湖那真是我见过最美的地方，从丽江报团一起过来，得五个多小时的时间，一路上都是悬崖峭壁的，如若说遇到下雨天随时都有可能遇到悬崖滚石、山体滑坡的，有的转弯的地方大巴车是需要两次转向才可以过去的，刚刚到达泸沽湖还只能很远的地方看到的时候，让我觉得很美的就是那里的蓝天，很美、很清澈，很多年都没见过这样的天空。 【观景台】第一站来到的是在泸沽湖入口的地方的一个全景观景台，这里看过去能远观到整个泸沽湖的全貌，天蓝水蓝，云朵清澈，真的是一种心旷神怡的感觉，这个地方拍照我们都没有用任何的美图软件，随便拍一张都是一幅天然的、优美的画面。 【草海 | 走婚桥】随着旅行团行程从观景台高处慢慢下来逐渐靠近湖面，我坐在大巴车上都能看到水下的水草，清澈见底，紧接着没有直接安排来湖边玩耍，先是到达的著名的草海和走婚桥，草海可能是因为季节的原因，还看不到长得很高的水草，草海岸边停靠着很多的猪槽船，这里不管是以前还是到未来，都会保留着这种古老的游湖方式，当地人对生态的保护确实是很重视的；草海的旁边就是有名的走婚桥，相传很久以前这里有一对小阿哥小阿妹在这里相爱，但是由于两家距离较远，家里人不同意他们在一起，于是他们就只能偷偷的在湖边约会，小阿哥是住在湖的对面，过来约会都得靠划着猪槽船来到这边，后来经过他们的努力，父母也同意他们在一起，于是他们就开始了走婚，有一天小阿哥来到这边走婚，却因为湖面风太大，掉进了湖里面就再也没有起来，小阿妹为了纪念小阿哥就在湖边亲自修了一座桥，同时也是为了后面的小阿哥小阿妹走婚方便，后人便将此桥命名为了走婚桥；走婚桥传言两个相爱的人需牵手一起走，中间不能有行人穿插，而且只能走一半，象征着爱情没有尽头。 【亲爱的客栈】紧接着来到了湖的另一边开始了我们的猪槽船之行，有当地的船夫给我们撑船，坐在船上手能接触到湖里的水，当时的气温差不多23度左右，水温大概在8-9度，水很凉而且很清澈，水下的水草一颗颗清晰可见，偶尔能看到水下的鱼，记不得品种的名字，听说湖里只有这一种鱼；随着船的前行慢慢来到了亲爱的客栈，这里对于我而言没有太多的观赏度，只是说这里前段时间刘涛、陈翔等明星来过此地拍节目因此有点名气，拍了几张照片就原路返回了。 【情人滩】顺着下午安排行程的最后一站是情人滩，这里可能在沿海地区的人来说算不上一个滩，在这里脚踏鹅卵石，牵着自己的爱人，也是一种美不胜收的感觉，走完情人滩差不多下午三点，一行人被带回了客栈休息。 【走婚宴】来到泸沽湖可能最让人记住的就是当地的风俗、文化，到了晚上六点，我们先是来到了当地一家人的家里吃有名的走婚宴，桌上的菜很有当地的特色，对于我来说吃得还算合胃口，当然不得不说说有名的猪膘肉，是他们在重大节日的时候才会吃的一道菜，猪膘肉听说是当地有小孩出生的时候孩子的阿舅就会宰杀一头猪用来制作猪膘肉，猪膘肉的制作是将猪肚里的内脏和瘦肉全部取干净之后，将虫草、藏红花等当地名贵的中药满满的塞在清理干净的猪肚子里，然后风干1-13年不等的时间，然后在重大的节日吃；对了，也许你会问，这么多年不会腐烂吗，他们在猪肚子里塞中草药的时候同时会在里面放当地的贡银，这才是保证这么多年不会腐烂的真正的东西，当然只是听说，不知道真假。 【摩梭人】讲到这里不得不先讲一下摩梭人，摩梭人并不在五十六个少数民族里面，有人说她是当地纳西族的分支，其实也不是，摩梭人就是一个独立的分支，听当地的文化讲解员的说法，他们也在不断申请成为中国第五十七个少数民族，但是由于人口目前只有四万人左右，还有点困难，当然他们还在继续申请；还有一个有趣的说法，因为当地摩梭人男不娶，女不嫁，走婚本来就是一种偷偷摸摸的风俗，晚上偷偷进去，早上偷偷梭出来，这就是摩梭人名字的由来，关于走婚，也是当地很有意思的风俗。 【走婚】晚上吃完走婚宴，就来到了当地一个举行篝火晚会的地方，这里像是一个四合院，差不多能容纳几百人，一进四合院门口就有人给我们献上了哈达，还留念拍了照，我们进去玩的那天也差不多有五百多人，围着中间的柴火一起唱歌、跳舞。为什么要在这里讲走婚呢，因为篝火晚会才是真正走婚的开始，走婚是当地摩梭人现在都还保留的风俗，男不聚，女不嫁，在篝火晚会的时候只要有你喜欢的小阿哥小阿妹，你就可以在跳舞的时候悄悄的扣对方的手心三下，如若对方也对你有意，然后他/她也会回复你三下，篝火晚会结束后他们就回到湖边约会，到了晚上零点过后小阿哥就要带着猪膘肉、匕首、腰带、帽子、银梳来到小阿妹的家里。先说下为什么要带这几样东西呢，因为摩梭人每家每户都有养狗，小阿哥半夜来到小阿妹家，就得先搞定她们家的狗，所以要带上猪膘肉；匕首不是用来防身的，小阿妹一般都是住在自己家二楼的花楼里，小阿哥不能直接走大门，必须得从墙壁攀爬上去，当然不是水泥墙，他们的房屋都是用不粗不细的圆滚木垒起来的，所以用匕首就方便攀爬；腰带是小阿哥走婚完了之后栓在床头一直延伸到窗台方便第二次来走婚的时候攀爬的；帽子是当小阿哥来到花楼之后，就要在窗边挂一顶帽子，说明此时他们正在走婚，不允许有人再来走婚或者打扰；银梳不是必须要带的，银梳是小阿哥决定此生只跟这一个小阿妹走婚，那么早上五六点离开的时候他就会在小阿妹的床头留下一把银梳，完了小阿妹每天都会将银梳别在头发上，别的小阿哥看到银梳，也不再会跟她走婚。走婚也叫暗婚，因为小阿哥小阿妹只有在晚上他们才会交流，白天走在路上擦肩而过都不会打招呼的，连小阿妹到此生生命结束家里的人也不会知道她的小阿哥是谁，这里的小孩都是13就成年，只有13岁以后他们才会知道他们的父亲是谁，但是在这个东方女儿国里面，女人才是掌权的，生下的孩子男方是不需要抚养的，女人在外面干活，男人只需要在家缝补衣服、照顾姐妹的孩子、做饭、家务事等，男人在这个地方叫“赔钱货”，没有地位的，所以一个女人要是连生了三个男孩，那么这个女人此生将地位特别低贱，如若这个女人此生不孕不育那么她将会被削发为尼；这个风俗至今都还保留，听说将来也不会消亡，可能这些东西在我们汉人看来很难理解，但这就是每个民族的特色与传统。 【摩梭人的生与死】 临走的这天早上，当地的文化讲解员带领我们走进了他们的家里参观，原始的摩梭人家的房子都是一个类似四合院的建筑，正对大门也就是正厅堂的那间房子叫做祖母屋，这间房子具有这个家庭绝对的权力和地位的，之前讲过这个都是女人掌权，祖母屋也就是住着整个家庭年龄最长的被上一任指认为祖母的女人；祖母屋的两边是自己的儿女住的地方，某一侧的二楼为年满13岁以上的女儿住的花楼；祖母屋没有主人的邀请是万万不可入内的，我们在文化讲解员的邀请下来到了他们家的祖母屋，先进的是我们旅游团的女同志们，跨门槛的时候必须是左脚进右脚出的，祖母屋的里面是一间大约15平米的房间，里面除了进门的这边，其余三边都是床，当然他们的床没有床头床尾，右手边地上是一个炉子，房间从中间隔开左边是一个比右边高出大约30公分的小平台，那里是家里聚会女人们坐的地方，下面才是家里男人们坐的地方；映入眼帘很显眼的地方就是房间的屋顶，上面都是一些手工雕花，据说都是家里的男人们刻出来的，正前方挂了很多的哈达，还有一些挂像，右手边的墙壁上是一块藏传佛教的祭拜台，上面有酥油灯，左手边的墙上有一扇很奇特的门，上了锁；中间是两根很粗的柱子，后来听讲解员说那时他们的小孩成人礼的时候用的，据说成人礼就是与狗互换年龄，所以他们从来不吃狗肉；讲解员带领我们坐下来，给我们介绍了当地的文化风俗以及当地的中医术，让我记得很清楚的还是他们当地的生与死；生，即出生，之前有讲过祖母屋的左手边有一扇门，那其实是一扇生死门，每一个摩梭人家里都有，这里的男人一辈子只能进去两次，那就是出生的时候和快最后一口气死亡的时候，女人除了出生和死亡，在生孩子的时候也是要在里面生的，她们生孩子没有手术台，没有剖腹产，只能靠阿舅（自己弟弟）去泸沽湖里面割一些芦苇回来编织成软软的垫子自己一个人在里面生，自己的小阿哥是不能来探望的，他们只会远远的隔着墙壁听听孩子的哭声，到了晚上小阿哥会给孩子送来一个银碗，象征着孩子以后衣食不愁，孩子出生基本都是由家里的男人们带大，直到成年。死，即死亡，摩梭人对逝去的人会有三种葬礼方式，一是天葬，二是火葬，再是土葬，三种方式按照顺序地位依次下降，土葬算是最卑微的方式了；天葬，即将死去的人分解成108块，然后供奉给老鹰、秃鹫动物吃掉，属于地位很高的；火葬，将死去的人架在火堆上火化成灰，然后将骨灰洒向大自然，所以我们来到这里几天，完全看不到一个墓碑、坟墓，他们的想法就是生不带来，死不带去，死后也不占用后人一点资源；然后就是土葬，执行这种葬礼的人是很卑微的，只有生前犯过大错的人才会执行，他们会在路边挖一个很深的坑，将死人埋在里面，上面填土与路面齐平，意喻受万人践踏，下十八层地狱。如果家里的祖母去世，将由下一任祖母背着走进生死门，然后在生死门里面由下一任祖母将去世的祖母洗浴干净，同时在尸体的嘴里、四肢、腹部放上银器，然后用白布包裹成一个婴儿的样子，象征着生不带来，死不带去，同时会在家里停放49天后再进行葬礼，最重要的是家里的父辈去世，家里的晚辈一个都不能伤心哭泣，因为他们寓意孝敬是在生前，而不是在去世之后；摩梭人对长辈是非常孝敬的，他们也要让子子孙孙看到他们的行为，让这种传统代代相传。 听到这些其实觉得他们真的很伟大，他们有自己的章法，保护大自然，遵循自然法则，让我觉得此行真的很值得，我觉得这才是真正旅行的意义。同时也很感叹，随着外界的接触和互联网等的影响，我不知道他们将来是否会原汁原味的保留现在的一切，很庆幸我们去的时候还能看到一些原始的东西，将来的他们不知道会怎么样。]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js的快速安装]]></title>
    <url>%2F2018%2F04%2F09%2FVue-js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Vue.js 教程 Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。 Vue 只关注视图层， 采用自底向上增量开发的设计。 Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 Vue 学习起来非常简单，本教程基于 Vue 2.1.8 版本测试。 安装vue.js的安装方式大致有三种，这里推荐一种npm的一种安装方式，npm版本必须大于3.0，如果低于这个版本请升级。 12345# 查看版本npm -v# 升级版本cnpm install npm -g 在用Vue.js构建大型应用时推荐使用NPM安装：1cnpm install vue Vue.js提供一个官方命令行工具，可用于快速搭建大型单页应用。12345678910111213141516171819202122232425262728293031# 全局安装cnpm install --global vue-cli# 创建一个基于webpack模板的新项目vue init webpack my-project # 后面需要进行一些配置，默认回车即可This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 my-project? Project name my-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated &quot;my-project&quot;. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack 进入项目，安装并运行：123456 cd my-project cnpm install cnpm run dev DONE Compiled successfully in 4388ms&gt; Listening at http://localhost:8080 ok!这个时候就看到帅气优雅的Vue.js的输出界面了！可以开始开发之旅了。 注意：Vue.js 不支持 IE8 及其以下 IE 版本。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery Ajax实例]]></title>
    <url>%2F2018%2F03%2F15%2FJquery-Ajax%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Jquery在异步提交方面封装的很好，直接用AJAX非常麻烦，Jquery大大简化了我们的操作，不用考虑浏览器的诧异了。 推荐一篇不错的jQuery Ajax 实例文章，忘记了可以去看看，地址为：http://www.cnblogs.com/yeer/archive/2009/07/23/1529460.html 和 http://www.w3school.com.cn/jquery/ 我们常用的一些$.post、$.get只是一些简单的、便捷的使用方法，如果要处理复杂的逻辑，还是需要用到jQuery.ajax()。因为jQuery.ajax()有它自身的处理机制，对于数据类型、cache、请求方式、返回处理等有详细的处理方式。 $.ajax的一般格式 1234567$.ajax(&#123; type: 'POST', url: url , data: data , success: success , dataType: dataType&#125;); $.ajax的参数描述: url 必需。规定把请求发送到哪个 URL。 data 可选。映射或字符串值。规定连同请求发送到服务器的数据。 success (data, textStatus, jqXHR) 可选。请求成功时执行的回调函数。 dataType 可选。规定预期的服务器响应的数据类型。 （xml、html、script、json、jsonp、text） cache(cacheBoolean) 可选。jQuery 1.2 新功能，设置为 false 将不缓存此页面。 contents 配对的对象，用来确定jQuery将如何解析响应，给定其内容类型。 回调函数如果要处理$.ajax()得到的数据，则需要使用回调函数。beforeSend、error、dataFilter、success、complete。 beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。 error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话） dataFilter 在请求成功之后调用。传入返回的数据以及”dataType”参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。 success 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。 complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串。 $.ajax需要注意的一些地方 data主要方式有三种，html拼接的，json数组，form表单经serialize()序列化的；通过dataType指定，不指定智能判断 $.ajax只提交form以文本方式，如果异步提交包含上传是传过不过去,需要使用jquery.form.js的$.ajaxSubmit $.ajax我的实际应用例子1、$.ajax带json数据的异步请求12345678910111213141516171819202122232425var aj = $.ajax( &#123; url:'productManager_reverseUpdate',// 跳转到 action data:&#123; selRollBack : selRollBack, selOperatorsCode : selOperatorsCode, PROVINCECODE : PROVINCECODE, pass2 : pass2 &#125;, type:'post', cache:false, dataType:'json', success:function(data) &#123; if(data.msg =="true" )&#123; // view("修改成功！"); alert("修改成功！"); window.location.reload(); &#125;else&#123; view(data.msg); &#125; &#125;, error : function() &#123; // view("异常！"); alert("异常！"); &#125; &#125;); 2、$.ajax序列化表格内容为字符串的异步请求123456789101112function noTips()&#123; var formParam = $("#form1").serialize();//序列化表格内容为字符串 $.ajax(&#123; type:'post', url:'Notice_noTipsNotice', data:formParam, cache:false, dataType:'json', success:function(data)&#123; &#125; &#125;); &#125; 3、$.ajax拼接url的异步请求1234567891011121314151617var yz=$.ajax(&#123; type:'post', url:'validatePwd2_checkPwd2?password2='+password2, data:&#123;&#125;, cache:false, dataType:'json', success:function(data)&#123; if( data.msg =="false" ) //服务器返回false，就将validatePassword2的值改为pwd2Error，这是异步，需要考虑返回时间 &#123; textPassword2.html("&lt;font color='red'&gt;业务密码不正确！&lt;/font&gt;"); $("#validatePassword2").val("pwd2Error"); checkPassword2 = false; return; &#125; &#125;, error:function()&#123;&#125; &#125;); 4、$.ajax拼接data的异步请求123456789101112$.ajax(&#123; url:'&lt;%=request.getContextPath()%&gt;/kc/kc_checkMerNameUnique.action', type:'post', data:'merName='+values, async : false, //默认为true 异步 error:function()&#123; alert('error'); &#125;, success:function(data)&#123; $("#"+divs).html(data); &#125; &#125;);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer.json架构]]></title>
    <url>%2F2018%2F03%2F15%2Fcomposer-json%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Root包“root 包”是指由 composer.json 定义的在你项目根目录的包。这是 composer.json 定义你项目所需的主要条件。（简单的说，你自己的项目就是一个 root 包）某些字段仅适用于“root 包”上下文。config 字段就是其中一个例子。只有“root 包”可以定义。在依赖包中定义的 config 字段将被忽略，这使得 config 字段只有“root 包”可用（root-only）如果你克隆了其中的一个依赖包，直接在其上开始工作，那么它就变成了“root 包”。与作为他人的依赖包时使用相同的 composer.json 文件，但上下文发生了变化。 属性包名 name包的名称，它包括供应商名称和项目名称，使用/分隔。eg:dept-jccp/zbj_agent 描述 description包的描述，对于需要发布的包（库），这个是必填的。 版本 versionversion不是必须的，可以忽略。通常，我们能够从 VCS (git, svn, hg) 的信息推断出包的版本号，在这种情况下，我们建议忽略 version。 安装类型 type包的安装类型，默认为 library。包的安装类型，用来定义安装逻辑。如果你有一个包需要一个特殊的逻辑，你可以设定一个自定义的类型。这可以是一个 symfony-bundle，一个 wordpress-plugin 或者一个 typo3-module。这些类型都将是具体到某一个项目，而对应的项目将要提供一种能够安装该类型包的安装程序。 composer原生支持以下4种类型： library: 这是默认类型，它会简单的将文件复制到vendor目录。 project: 这表示当前包是一个项目，而不是一个库。例：框架应用程序 Symfony standard edition，内容管理系统 SilverStripe installer 或者完全成熟的分布式应用程序。使用 IDE 创建一个新的工作区时，这可以为其提供项目列表的初始化。 metapackage: 当一个空的包，包含依赖并且需要触发依赖的安装，这将不会对系统写入额外的文件。因此这种安装类型并不需要一个 dist 或 source。 composer-plugin: 一个安装类型为 composer-plugin 的包，它有一个自定义安装类型，可以为其它包提供一个 installler。详细请查看 自定义安装类型。 仅在你需要一个自定义的安装逻辑时才使用它。建议忽略这个属性，采用默认的 library。 关键词 keyword该包相关的关键词的数组。这些可用于搜索和过滤。 项目主页 homepage该项目网站的 URL 地址。可选。 版本发布时间 time版本发布时间。必须符合 YYYY-MM-DD 或 YYYY-MM-DD HH:MM:SS 格式。可选。 许可协议 license包的许可协议，它可以是一个字符串或者字符串数组。最常见的许可协议的推荐写法（按字母排序）： Apache-2.0 BSD-2-Clause BSD-3-Clause BSD-4-Clause GPL-2.0 GPL-2.0+ GPL-3.0 GPL-3.0+ LGPL-2.1 LGPL-2.1+ LGPL-3.0 LGPL-3.0+ MIT可选。 对于闭源软件，你必须使用 “proprietary” 协议标识符。123&#123; "license": "MIT"&#125; 对于一个包，当允许在多个许可协议间进行选择时（”disjunctive license”），这些协议标识符可以被指定为数组。多协议的一个例：123456&#123; "license": [ "LGPL-2.1", "GPL-3.0+" ]&#125; 另外它们也可以由 “or” 分隔，并写在括号中：123&#123; "license": "(LGPL-2.1 or GPL-3.0+)"&#125; 同样，当有多个许可协议需要结合使用时（”conjunctive license”），它们应该被 “and” 分隔，并写在括号中。 作者 authors包的作者。这是一个对象数组。这个对象必须包含以下属性： name: 作者的姓名，通常使用真名。 email: 作者的 email 地址。 homepage: 作者主页的 URL 地址。 role: 该作者在此项目中担任的角色（例：开发人员 或 翻译）。 12345678910111213141516&#123; "authors": [ &#123; "name": "Nils Adermann", "email": "naderman@naderman.de", "homepage": "http://www.naderman.de", "role": "Developer" &#125;, &#123; "name": "Jordi Boggiano", "email": "j.boggiano@seld.be", "homepage": "http://seld.be", "role": "Developer" &#125; ]&#125; 可选，但强烈建议提供此内容。 支持 support取项目支持的向相关信息对象。这个对象必须包含以下属性： email: 项目支持 email 地址。 issues: 跟踪问题的 URL 地址。 forum: 论坛地址。 wiki: Wiki 地址。 irc: IRC 聊天频道地址，类似于 irc://server/channel。 source: 网址浏览或下载源。 123456&#123; "support": &#123; "email": "support@example.org", "irc": "irc://irc.freenode.org/composer" &#125;&#125; Package links下面提到的所有对象，都应该是 包名 到 版本 的映射对象。12345&#123; "require": &#123; "monolog/monolog": "1.0.*" &#125;&#125; 所有的这些都是可选的。 suggest建议安装的包，它们增强或能够与当前包良好的工作。这些只是信息，并显示在依赖包安装完成之后，给你的用户一个建议，他们可以添加更多的包。 格式如下，版本约束变成了描述信息。12345&#123; "suggest": &#123; "monolog/monolog": "Allows more advanced logging of the application flow" &#125;&#125; autoloadPHP autoloader 的自动加载映射。12345678&#123; "autoload": &#123; "psr-4": &#123; "Monolog\\": "src/", "Vendor\\Namespace\\": "" &#125; &#125;&#125; 推荐推荐一些常用的依赖： predis/predis nesbot/carbon react/http-client itsgoingd/clockwork codeception/verify qiniu/php-sdk dingo/api urmaul/httpclient nmred/kafka-php ramsey/uuid spatie/laravel-pjax douyasi/laravel-editor-md]]></content>
      <categories>
        <category>composer</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Hexo Next主题添加哈林摇特效]]></title>
    <url>%2F2018%2F02%2F05%2F%E4%B8%BAHexo-Next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%93%88%E6%9E%97%E6%91%87%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[前几天看到一个博友的博客特别的动感，后面查阅资料后才知道那个特效叫哈林摇特效，花了点时间整理了下这个特效在Hexo NEXT主题下的实现方式，出来的效果还不错，让自己的博客变得十分的动感，低调又不失活跃。效果的演示可以看本博客站点概要里面High按钮，尝试点击体验,效果很动感，页面有激烈的跳动，带上耳机还可以听到动感的音乐，有喜欢的朋友可以放在自己的博客上。 话不多说，看下实现方式。 三个步骤： 创建特效文件 在主题目录中，创建layout\_macro\high.swig，添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;a title="收藏到书签，偶尔High一下^_^" rel="alternate" class="mw-harlem_shake_slow wobble shake" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125;&#125;)()'&gt;&lt;i class="fa fa-music"&gt;&lt;/i&gt; High&lt;/a&gt; 引用特效代码 在侧边栏，引用特效代码。在主题目录，修改layout\_macro\sidebar.swig： 1&#123;% include 'high.swig' %&#125; 样式修改 将”High”和”RSS”并排展示，在主题目录中，修改source\css\_schemes\Pisces\_sidebar.styl 1display: inline-block; 优化关于优化，建议将layout_macro\high.swig中的harlem-shake.mp3和harlem-shake.css放到cdn上，然后引用cdn地址，加快访问速度。 当然，上述只是一个标准的版本，可以根据自己的探索设置成不同效果的哈林摇，欢迎脑洞探索和关注留言共同探讨！]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客添加背景动画]]></title>
    <url>%2F2018%2F02%2F05%2FHexo-%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[快速操作背景动画基于canvas，添加到博客上也比较简单，在\themes\next\layout\_layout.swig的&lt;/body&gt;上面添加123&#123;% if theme.canvas_nest %&#125; &lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 在\themes\next\_config.yml中添加以下字段开启此功能：1234# background settings# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 优化以上两步做完之后页面能看到效果，但是会有一些兼容问题，特别是在手机上，下面操作后会排除兼容问题。 添加完了，发现博客背景是白色，会遮住动画，只留下两边一点点的位置看到动画效果，这时候可以去设置一下背景颜色，在\themes\next\source\css\_schemes\Pisces\_layout.styl中，把.content-wrap中的background修改为none。 这时候如果用手机打开，也能看到动画效果，但是带来的体验不好，显得页面比较乱，这是可以把.content-wrap的+mobile()中的background修改为white，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。 附上我的.content-wrap配置：12345678910111213141516171819202122.content-wrap &#123; float: right; box-sizing: border-box; padding: $content-desktop-padding; width: $content-desktop; background: none; min-height: 700px; box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +tablet() &#123; width: 100%; padding: 20px; border-radius: initial; &#125; +mobile() &#123; width: 100%; padding: 20px; min-height: auto; border-radius: initial; background: white; &#125;&#125; 修改一些样式never_yu‘Blog中的文章添加许多样式，看了一下github上的源码，在 themes\next\source\css\_custom\custom.styl 中，添加如下css：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355//修改文章内链接文本样式.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125;//修改不在文章内的链接文本样式.link-blue&#123; color: #f36; &amp;:hover &#123; color: #f00; &#125;&#125;//修改文章内code样式code &#123;color:#fff;background:#333;&#125;//修改文章中图片样式，改为居中.posts-expand .post-body img &#123; margin: 0 auto;&#125;// 下载样式a#download &#123; display: inline-block; padding: 0 10px; color: #000; background: transparent; border: 2px solid #000; border-radius: 2px; transition: all .5s ease; font-weight: bold; &amp;:hover &#123; background: #000; color: #fff; &#125;&#125;//阅读全文样式.post-more-link .btn &#123; position:relative; border: 2px solid #000; border-radius: 2px; padding: 0 10px; font-weight: bold; background: transparent; transition: all .5s ease; &amp;:hover &#123; background: #000; color: #eee; &#125;&#125;//// 颜色块-黄span#inline-yellow &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #f0ad4e;&#125;// 颜色块-黑span#inline-black &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: black;&#125;// 颜色块-绿span#inline-green &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #9954bb;&#125;// 颜色块-红span#inline-red &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #df3e3e;&#125;// 左侧边框红色块级p#div-border-left-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #9954bb;&#125;//动画模块//第一篇博客中-精于心，简于形-的动画（https://neveryu.github.io/page/2/）span#yu-1 &#123; display:inline; position:relative; border-top:1px solid #222; border-bottom:1px solid #222; font-size:110%; cursor:pointer; &amp;:hover &#123; background-color: #000; color: #fff; animation: animate-yu-1 3s ease-in; &#125;&#125;@keyframes animate-yu-1 &#123; 0% &#123; left:-10px; top:0px; &#125; 10% &#123; left:10px; top:0px; &#125; 20% &#123; left:-8px; top:0px; &#125; 30% &#123; left:8px; top:0px; &#125; 40% &#123; left:-5px; top:0px; &#125; 50% &#123; left:5px; top:0px; &#125; 60% &#123; left:-3px; top:0px; &#125; 70% &#123; left:3px; top:0px; &#125; 80% &#123; left:-1px; top:0px; &#125; 90% &#123; left:1px; top:0px; &#125; 100% &#123; left:0px; top:0px; &#125;&#125;//留言页面-[最近访客]-的样式span#yu-2 &#123; display:inline; position:relative; border-top:1px solid #222; border-bottom:1px solid #222; font-size:130%;&#125;]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成功实施DevOps的七个有力工具]]></title>
    <url>%2F2018%2F02%2F05%2F%E6%88%90%E5%8A%9F%E5%AE%9E%E6%96%BDDevOps%E7%9A%84%E4%B8%83%E4%B8%AA%E6%9C%89%E5%8A%9B%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[如今，每个软件企业都在谈论DevOps，他们希望从DevOps中获得好处。DevOps本身不是开发工具，而是开发文化的一次革新，为了能够成功地实施DevOps，需要借助一些工具。Pavan Belagatti列出了7个强有力的工具可以帮助企业成功地实施DevOps。 DockerDocker是容器市场的领头羊。随着越来越多的软件企业采用了微服务架构，容器化也成为一个大趋势。在接下来的几年，Docker会变得越来越流行。我们已经在生产环境使用Docker部署了很多服务。Docker简化了配置管理，提升了可操控性，并让横向扩展变得简单。Docker还能让容器在不同的位置自由地移动。 Git（GitHub）Git是一个免费的开源分布式版本控制系统，不管是小型应用还是大型应，它都能应付自如。Git创建于10年前，因为当时的Linux社区需要这么一个可以支持分布式系统的SCM（Source Control Management）软件。这个平台有助于开发者们在上面进行协作。它的那些主要特性，比如代码仓库、代码拉取等等，对开发人员来说很有吸引力。与GitHub的集成十分容易，几乎任何系统都可以连接到GitHub上，没有什么特殊限制。GitHub还可以作为一个网络社交平台，你可以在上面放置你的个人信息和项目相关的数据。GitHub优于其它SCM工具的地方在于，它支持本地分支、过度区域和多工作流。 AWSAWS为企业组织提供了灵活的服务，帮助企业高效地交付软件产品。相比敏捷，DevOps能够更快地交付产品，为了做到这一点，AWS为各个公司提供了强大的云计算服务。这些服务包括计算、存储、网络、数据库、数据分析、应用服务、部署、管理、移动、开发者工具以及IoT工具。 JIRAJIRA是来自Altassian公司的一款很受欢迎的敏捷开发工具，它提供了众多功能，比如缺陷跟踪、问题跟踪，并在某种程度上为企业提供了项目管理功能。它还支持Scrum、看板、敏捷报告、组合计划、插件、移动应用，并提供了一组健壮的API。 Ansible可以使用Ansible为DevOps打下牢固的根基。Ansible是一个简单但却十分强大的配置管理服务器，它帮助团队横向扩展IT自动化规模，管理复杂的部署，并提高生产力。它为团队乃至整个企业带来自动化。很多成功的公司都在使用Ansible来促进IT自动化，而且一旦用了Ansible就不会再考虑其它解决方案了。企业之所以喜欢Ansible，是因为它提供了一种完全不可变的服务器架构。不可变的服务器架构可以保证在添加、销毁或替换服务器时不会对服务造成任何影响。 SlackSlack是一个集成工具，任何想实践敏捷和DevOps的组织都可以使用它。它容易监控，还支持通知机制，是一个简单且强大的工具。Slack通过创建通信通道来自动化执行常见的任务，并用它来分发实时信息，缩短团队间的反馈延迟，加快团队的行动，提升团队的生产力。 ShippableShippable可以帮助软件企业加快创新进程。它是一个流水线式的持续部署平台，一般被作为托管服务或企业服务器来帮助软件企业走向现代化。它让编码、打包、部署、运行Docker容器变得更容易。Shippable通过它的CI和CD平台来支持自动化。它在不破坏安全性的前提下使用顺畅的部署来自动化执行那些重复的、机械化的任务。]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JSON获取Bing每日背景图片]]></title>
    <url>%2F2018%2F02%2F02%2F%E7%94%A8JSON%E8%8E%B7%E5%8F%96Bing%E6%AF%8F%E6%97%A5%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[经过访问BING的网址最终发现，bing中文网一直在提供每日更新背景图片壁纸的json数据.访问网址：http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1根据上面地址的结构，我暂时研究到就三项属性有效，他们分别是: format，非必要。我理解为输出格式，不存在或者不等于js，即为xml格式，等于js时，输出json格式； idx，非必要。不存在或者等于0时，输出当天的图片，-1为已经预备用于明天显示的信息，1则为昨天的图片，idx最多获取到前16天的图片信息；* n，必要。这是输出信息的数量，比如n=1，即为1条，以此类推，至多输出8条；* *号注释：此处我们要注意的时，是否正常的输出信息，与n和idx有关，通过idx的值，我们就可以获得之前bing所使用的背景图片的信息了。 提供一个我正在用json转php，调用图片地址的方法:123$str = file_get_contents('http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1'); $array = json_decode($str); $imgurl = $array-&gt;&#123;"images"&#125;[0]-&gt;&#123;"url"&#125;; 亲测方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * 从bing上获取背景图片 */class model_op_bing extends components_basemodel&#123; const CACHE_BING_PIC = "op.bing.%s"; /** * @var Cache_MemCache */ protected $cache = null; public function __construct($pkid = false) &#123; parent::__construct($pkid); $this-&gt;cache = SCache::getCacheEngine("Memcache"); $this-&gt;cache-&gt;init(array('servers' =&gt; lib_Constant::$MEMCACHE_SERVERS)); &#125; public function getBackground($isForce=false) &#123; $cacheKey = sprintf(self::CACHE_BING_PIC, date("Y_m_d",time())); if ( $this-&gt;cache-&gt;get($cacheKey) &amp;&amp; false == $isForce ) &#123; return $this-&gt;cache-&gt;get($cacheKey); &#125; $picSuffix = 'http://cn.bing.com'; $result = file_get_contents( sprintf('%s%s', $picSuffix, '/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1') ); $bing = json_decode($result); $imgurl = $bing-&gt;&#123;"images"&#125;[0]-&gt;&#123;"url"&#125;; $imgurl = false === strpos($picSuffix, $imgurl) ? sprintf('%s%s', $picSuffix, $imgurl) : $imgurl; $type = pathinfo($imgurl, PATHINFO_EXTENSION); $data = file_get_contents($imgurl); $base64 = 'data:image/' . $type . ';base64,' . base64_encode($data); $this-&gt;cache-&gt;set($cacheKey, $base64, 43200); return $base64; &#125;&#125; 调用方：12$params['backgroundImg'] = (date('Ymd') == '20161208' || date('Ymd') == '20161209') ? "/assets/op/img/1208_index.jpg" : $bingModel-&gt;getBackground((!empty($_GET['update'])) ? true : false);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个重要函数（获取无限极菜单+批量排序）]]></title>
    <url>%2F2018%2F02%2F02%2F%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%EF%BC%88%E8%8E%B7%E5%8F%96%E6%97%A0%E9%99%90%E6%9E%81%E8%8F%9C%E5%8D%95-%E6%89%B9%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[以下两个函数是自己在接触PHP的时候学到的，这里做一下记录只是为了怀念那个时候对于行业的那种陌生感和探索欲望，这两个函数虽然不是很难，但是用的地方不少，比如获取目录树，可以用在对类目的管理、评论等无限级的地方都可以用，话不多说，请看代码。 获取目录树1234567891011121314151617181920212223242526272829303132333435363738/*** 得到菜单栏目树* @author xiexiang 2016-03-17* @params eg $map = "name = 'xiexiang'" //查询条件**/public function getMenu($map )&#123; //实例化数据表menu $menu = new model_op_menu() ; $order = "ORDER BY level ASC,sort DESC"; $menu_list = $menu-&gt; select($map , '', '', $order , '', ''); $mod_list = $menu_list-&gt; items; if (!$mod_list || empty( $mod_list)) &#123; return false; &#125; $tmp = array() ; $address = array() ; //父级地址 foreach ($mod_list as $k =&gt; $v) &#123; $id = $v[ 'id']; if ($v ['level'] &lt;= 1) &#123; //一级 $tmp [$id] = $v; $address [$id] = &amp; $tmp[$id ]; &#125; else &#123; //子集 $pid = $v[ 'pid']; if (!$address[ $pid]['child' ]) &#123; $address[ $pid]['child' ] = array() ; &#125; $address [$pid][ 'child'][$id ] = $v; $address [$id] = &amp; $address[$pid ]['child'][ $id]; &#125; &#125; return $tmp;&#125; 批量排序123456789101112131415161718192021222324252627282930313233/*** 批量排序*/public function pagesort()&#123; //异常插入 try &#123; $sort = lib_BaseUtils::getStr( $_GET['sort' ]); if (empty( $sort)) &#123; throw new Exception( '请选择需要排序的数据！' , 0) ; &#125; foreach ( $sort as $k =&gt; $v) &#123; if (!is_numeric( $k) || !is_numeric($v )) &#123; continue; &#125; $sql_bat_sort .= " WHEN &#123; $k&#125; THEN &#123;$v&#125; "; $sql_ids .= ',' . $k; &#125; $menu = new model_op_menu() ; $sql = "UPDATE op_menu SET sort= CASE id " . $sql_bat_sort . " END WHERE id IN (" . trim($sql_ids , ', ') . ")"; $menu -&gt;query( $sql); throw new Exception('批量排序成功！', 1 ); &#125; catch (Exception $e ) &#123; return $this -&gt;printmsg( $e-&gt;getMessage (), $e -&gt;getCode()) ; &#125;&#125; 巧办法上诉的获取目录树也可以用通过更加简单的办法来实现，在数据库设计合理的情况下，可以使用递归的方式来做。1234567891011121314151617181920/** * - 得到树形处理后的分类列表 * @param int $pid * @param array $result * @param int $space * @return array */ public function getTree($pid=0,&amp;$result=[],$space=0) &#123; $space+=2; $parents = Category::where('cate_pid',$pid)-&gt;orderBy('cate_order','DESC')-&gt;get(); foreach ($parents as $key =&gt; $val)&#123; if ($val-&gt;cate_pid != 0)&#123; $val['cate_name'] = str_repeat('&amp;nbsp;&amp;nbsp;&amp;nbsp;',$space).'▲ '.$val['cate_name']; &#125; $result[] = $val; $this-&gt;getTree($val-&gt;cate_id,$result,$space); &#125; return $result; &#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云图床API接口指南]]></title>
    <url>%2F2018%2F02%2F02%2F%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8AAPI%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[登录到七牛云官网注册一个账号地址：http://www.qiniu.com 获取对应的七牛云秘钥位置：个人面板-&gt;秘钥管理获取一对 AccessKey/SecretKey 秘钥 建立存储空间位置：对象存储对象存储中可以管理上传的文件、对空间的设置、域名绑定、样式分割符设置及图片样式设定。 基本用法文档地址：http://developer.qiniu.com/code/v7/sdk/php.html#usage 1、引入SDK无论你是通过哪种方式安装的 SDK，只需要一句简单的 require 语句将安装好的SDK包含到你的项目中。请参考如下表格，找到适合你的安装方式，将SDK引入到你的项目中。请用你项目中的实际路径替换 path_to_sdk。 1234567891011Composer 安装require 'path_to_sdk/vendor/autoload.php';下载Composer安装包require 'path_to_sdk/vendor/autoload.php';下载源码安装包require 'path_to_sdk/autoload.php'; 2、SDK结构 可以直接查看我们的SDK目录，即可大致了解我们SDK的结构。 最外层包含：配置文件， 鉴权和一些公共的函数 HTTP 目录主要包含了一些对 http 进行封装的类，这块你可以不用关心。 Storage 目录主要包含两大块：Bucket 中文件的管理和文件的上传。 Processing 目录主要包含文件的处理，文件处理又包含两个方面：同步处理和异步处理。 为了帮助您更好的了解和使用我们的sdk，我们还提供了各种使用示例。 如果使用中遇到问题，可以通过Github或者我们的工单进行反馈。下面我们对一些关键点进行简单的介绍，方便您快速入门。 3、鉴权类在使用七牛的SDK的过程中鉴权是很重要的一块，不管是上传鉴权，下载签权， 还是回调的签权。 PHP SDK 中的Auth类封装了所有的鉴权方式。 所以在使用 PHP SDK 时基本都会先对鉴权类进行初始化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php require 'path_to_sdk/vendor/autoload.php'; use Qiniu\Auth; // 用于签名的公钥和私钥 $accessKey = 'Access_Key'; $secretKey = 'Secret_Key'; // 初始化签权对象 $auth = new Auth($accessKey, $secretKey);```` 初始化好Auth 类后，就可以调用相应的方法了，比如生成私有下载链接方法 privateDownloadUrl，获取上传Token方法 uploadToken，验证回调方法 verifyCallback等。### 上传流程````php&lt;?php require_once 'path_to_sdk/vendor/autoload.php'; //引入类库文件 建议用composer方式 // 引入鉴权类 use Qiniu\Auth; //命名空间 // 引入上传类 use Qiniu\Storage\UploadManager; //命名空间 // 需要填写你的 Access Key 和 Secret Key //这里就用到了注册账户后用到的两个秘钥 $accessKey = 'Access_Key'; $secretKey = 'Secret_Key'; // 构建鉴权对象 $auth = new Auth($accessKey, $secretKey); // 要上传的空间 $bucket = 'Bucket_Name'; //设定的上传空间名 // 生成上传 Token $token = $auth-&gt;uploadToken($bucket); // 要上传文件的本地路径 $filePath = './php-logo.png'; //上传时候图片在本地的路径 // 上传到七牛后保存的文件名 $key = 'my-php-logo.png'; //保存到七牛上面的命名 // 初始化 UploadManager 对象并进行文件的上传 $uploadMgr = new UploadManager(); // 调用 UploadManager 的 putFile 方法进行文件的上传 list($ret, $err) = $uploadMgr-&gt;putFile($token, $key, $filePath); echo "\n====&gt; putFile result: \n"; if ($err !== null) &#123; var_dump($err); //返回结果根据需要处理 &#125; else &#123; var_dump($ret); &#125; 文件下载1234567891011121314151617&lt;?php require 'path_to_sdk/vendor/autoload.php'; // 引入鉴权类 use Qiniu\Auth; // 需要填写你的 Access Key 和 Secret Key $accessKey = 'Access_Key'; $secretKey = 'Secret_Key'; // 构建鉴权对象 $auth = new Auth($accessKey, $secretKey); //baseUrl构造成私有空间的域名/key的形式 $baseUrl = 'http://domain/key'; //空间名+文件名 的格式 $authUrl = $auth-&gt;privateDownloadUrl($baseUrl); //加密处理后再返回 echo $authUrl;?&gt; 删除单个文件123456789101112131415161718192021222324252627&lt;?php require_once 'path_to_sdk/vendor/autoload.php'; use Qiniu\Auth; use Qiniu\Storage\BucketManager; $accessKey = 'Access_Key'; $secretKey = 'Secret_Key'; //初始化Auth状态 $auth = new Auth($accessKey, $secretKey); //初始化BucketManager $bucketMgr = new BucketManager($auth); //你要测试的空间， 并且这个key在你空间中存在 $bucket = 'Bucket_Name'; $key = 'php-logo.png'; //删除$bucket 中的文件 $key $err = $bucketMgr-&gt;delete($bucket, $key); //空间名 和 未加密的文件名 echo "\n====&gt; delete $key : \n"; if ($err !== null) &#123; var_dump($err); &#125; else &#123; echo "Success!"; &#125; 还有更多的操作请参考官方文档，地址：http://developer.qiniu.com/code/v7/sdk/php.html#install 实际案例（实战项目中的方法封装） 12345/七牛云图片上传配置const ACCESS_KEY = 'byJc-8owLt9G5ljXsNYbTsfOCKzQgTV4UTPu3sCG' ; //私钥AKconst SECRET_KEY = '6ybTxRxyDGndimpVMgK_k-6s1prGIPkGtB0Xolyb' ; //私钥SKconst QINIU_BUCKET = 'op-zbj' ; //空间名（对象存储中）const BASE_URL = 'http://ohsllkayi.bkt.clouddn.com' ; //外链默认域名（对象存储-&gt;内容管理） 1234567891011121314151617181920212223242526272829/*** 上传图片到七牛云* @param $filePath 图片的本地路径* @param $fileName 图片名* @return mixed array* @throws Exception*/public function UploadPicToQiNiu ($fileName , $filePath)&#123; // 初始化签权对象 $auth = new Auth(lib_Constant:: ACCESS_KEY , lib_Constant:: SECRET_KEY ); // 生成上传 Token $token = $auth-&gt; uploadToken (lib_Constant:: QINIU_BUCKET) ; // 上传到七牛后保存的文件名 $key = 'qiniu_'.md5( $fileName .rand(100 , 999)) ; // 初始化 UploadManager 对象并进行文件的上传 $uploadMgr = new UploadManager() ; // 调用 UploadManager 的 putFile 方法进行文件的上传 list ( $ret, $err ) = $uploadMgr -&gt; putFile( $token , $key , $filePath) ; if ($err !== null) &#123; return $err ; &#125; else &#123; return $ret ; &#125;&#125; 1234567891011121314/*** 从七牛云上获取图片到本地* @param $filePath 数据库中的图片地址* @return string*/public function downloadPicToQiNiu ($filePath )&#123; // 构建鉴权对象 $auth = new Auth(lib_Constant:: ACCESS_KEY , lib_Constant:: SECRET_KEY ); //baseUrl构造成私有空间的域名/key的形式 $baseUrl = lib_Constant:: BASE_URL. '/' .$filePath ; $authUrl = $auth-&gt; privateDownloadUrl ($baseUrl ) ; return $authUrl;&#125; 1234567891011121314151617181920/*** 批量获取七牛云上的图片* @param $filePathArray* @return array|bool*/public function batchDownloadPicToQiNiu ( $filePathArray)&#123; if ( empty( $filePathArray ))&#123; return false; &#125; // 构建鉴权对象 $returnFullImagesPath = [] ; $auth = new Auth(lib_Constant:: ACCESS_KEY , lib_Constant:: SECRET_KEY ); foreach ($filePathArray as $filePath)&#123; //baseUrl构造成私有空间的域名/key的形式 $baseUrl = lib_Constant:: BASE_URL. '/' .$filePath ; $returnFullImagesPath [] = $auth -&gt;privateDownloadUrl ( $baseUrl) ; &#125; return $returnFullImagesPath ;&#125; 123456789101112131415161718192021/*** 从七牛云上删除图片* @param $filePath* @return mixed*/public function deleteToQiNiu ($filePath )&#123; //初始化Auth状态 $auth = new Auth(lib_Constant:: ACCESS_KEY , lib_Constant:: SECRET_KEY ); //初始化BucketManager $bucketMgr = new BucketManager( $auth ); //删除$bucket 中的文件 $key $err = $bucketMgr -&gt; delete(lib_Constant:: QINIU_BUCKET ,$filePath ) ; // echo "\n====&gt; delete $key : \n"; if ( $err !== null ) &#123; return fasle ; &#125; else &#123; return true; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中静态方法(static)与非静态方法的使用及区别]]></title>
    <url>%2F2018%2F02%2F02%2FPHP%E4%B8%AD%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-static-%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[表述 static方法是类中的一个成员方法,属于整个类,即使不用创建任何对象也可以直接调用! 静态方法效率上要比实例化高，静态方法的缺点是不自动进行销毁，而实例化的则可以做销毁 静态方法和静态变量创建后始终使用同一块内存，而使用实例的方式会创建多个内存。 C++中，若类的方法前加了static关键字，则该方法称为静态方法，反之为实例方法。静态方法为类所有，可以通过对象来使用，也可以通过类来使用。但一般提倡通过类名来使用，因为静态方法只要定义了类，不必建立类的实例就可使用。静态方法只能用类的静态成员 static关键字用来修饰属性、方法，称这些属性、方法为静态属性、静态方法。 static关键字声明一个属性或方法是和类相关的，而不是和类的某个特定的实例相关，因此，这类属性或方法也称为“类属性”或“类方法” 如果访问控制权限允许，可不必创建该类对象而直接使用类名加两个冒号“::”调用。 static关键字可以用来修饰变量、方法。 不经过实例化，就可以直接访问类中static的属性和static的方法。 static 的属性和方法，只能访问static的属性和方法，不能类访问非静态的属性和方法。因为静态属性和方法被创建时，可能还没有任何这个类的实例可以被调用. static的属性，在内存中只有一份，为所有的实例共用 使用self:: 关键字访问当前类的静态成员. 一个类的所有实例，共用类中的静态属性 实现下面例子中的设置了一个计数器$count属性，设置private 和 static 修饰。这样，外界并不能直接访问$count属性。而程序运行的结果我们也看到多个实例在使用同一个静态的$count 属性12345678910111213141516171819202122&lt;?PHP class user &#123; private static $count = 0 ; //记录所有用户的登录情况. public function __construct() &#123; self::$count = self::$count + 1; &#125; public function getCount() &#123; return self::$count; &#125; public function __destruct() &#123; self::$count = self::$count - 1; &#125; &#125; $user1 = new user(); $user2 = new user(); $user3 = new user(); echo "now here have " . $user1-&gt;getCount() . " user"; echo "&lt;br /&gt;"; unset($user3); echo "now here have " . $user1-&gt;getCount() . " user"; ?&gt; 静态属性直接调用,静态属性不需要实例化就可以直接使用，在类还没有创建时就可以直接使用 使用的方式是： 类名::静态属性名123456789101112131415&lt;?php class Math &#123; public static $pi = 3.14; &#125; // 求一个半径3的园的面积。 $r = 3; echo "半径是 $r 的面积是&lt;br /&gt;"; echo Math::$pi * $r * $r; echo "&lt;br /&gt;&lt;br /&gt;"; //这里我觉得 3.14 不够精确，我把它设置的更精确。 Math::$pi = 3.141592653589793; echo "半径是 $r 的面积是&lt;br /&gt;"; echo Math::$pi * $r * $r; ?&gt; 类没有创建，静态属性就可以直接使用。那静态属性在什么时候在内存中被创建？ 在PHP中没有看到相关的资料。引用Java中的概念，来解释应该也具有通用性 静态方法静态方法不需要所在类被实例化就可以直接使用。 使用的方式是类名：：静态方法名 下面我们继续写这个Math类，用来进行数学计算。我们设计一个方法用来算出其中的最大值。既然是数学运算，我们也没有必要去实例化这个类，如果这个方法 可以拿过来就用就方便多了。我们这只是为了演示static方法而设计的这个类。在PHP提供了 max() 函数比较数值。123456789101112131415161718192021&lt;?php class Math &#123; public static function Max($num1, $num2) &#123; return $num1 &gt; $num2 ? $num1 : $num2; &#125; &#125; $a = 99; $b = 88; echo "显示 $a 和 $b 中的最大值是"; echo "&lt;br /&gt;"; echo Math::Max($a, $b); echo "&lt;br /&gt;"; echo "&lt;br /&gt;"; echo "&lt;br /&gt;"; $a = 99; $b = 100; echo "显示 $a 和 $b 中的最大值是"; echo "&lt;br /&gt;"; echo Math::Max($a,$b); ?&gt; 静态方法如何调用静态方法第一个例子，一个静态方法调用其它静态方法时，使用self::123456789101112131415161718192021&lt;?php // 实现最大值比较的Math类。 class Math &#123; public static function Max($num1, $num2) &#123; return $num1 &gt; $num2 ? $num1 : $num2; &#125; public static function Max3($num1, $num2, $num3) &#123; $num1 = self::Max($num1, $num2); $num2 = self::Max($num2, $num3); $num1 = self::Max($num1, $num2); return $num1; &#125; &#125; $a = 99; $b = 77; $c = 88; echo "显示 $a $b $c 中的最大值是"; echo "&lt;br /&gt;"; echo Math::Max3($a, $b, $c); ?&gt; 静态方法调用静态属性使用self:: 调用本类的静态属性。123456789101112&lt;?php // class Circle &#123; public static $pi = 3.14; public static function circleAcreage($r) &#123; return $r * $r * self::$pi; &#125; &#125; $r = 3; echo " 半径 $r 的圆的面积是 " . Circle::circleAcreage($r); ?&gt; 静态方法不能调用非静态属性 。不能使用self::调用非静态属性。 123456789101112&lt;?php // 这个方式是错误的 class Circle &#123; public $pi = 3.14; public static function circleAcreage($r) &#123; return $r * $r * self::pi; &#125; &#125; $r = 3; echo " 半径 $r 的圆的面积是 " . Circle::circleAcreage($r); ?&gt; 也不能使用 $this 获取非静态属性的值。 静态方法调用非静态方法PHP5中，在静态方法中不能使用 $this 标识调用非静态方法.12345678910111213141516171819202122&lt;?php // 实现最大值比较的Math类。 class Math &#123; public function Max($num1, $num2) &#123; echo "bad&lt;br /&gt;"; return $num1 &gt; $num2 ? $num1 : $num2; &#125; public static function Max3($num1, $num2, $num3) &#123; $num1 = $this-&gt;Max($num1, $num2); $num2 = $this-&gt;Max($num2, $num3); $num1 = $this-&gt;Max($num1, $num2); return $num1; &#125; &#125; $a = 99; $b = 77; $c = 188; echo "显示 $a $b $c 中的最大值是"; echo "&lt;br /&gt;"; echo Math::Max3($a, $b, $c); //同样的这个会报错 ?&gt; 当一个类中有非静态方法被self:: 调用时，系统会自动将这个方法转换为静态方法。123456789101112131415161718192021&lt;?php // 实现最大值比较的Math类。 class Math &#123; public function Max($num1, $num2) &#123; return $num1 &gt; $num2 ? $num1 : $num2; &#125; public static function Max3($num1, $num2, $num3) &#123; $num1 = self::Max($num1, $num2); $num2 = self::Max($num2, $num3); $num1 = self::Max($num1, $num2); return $num1; &#125; &#125; $a = 99; $b = 77; $c = 188; echo "显示 $a $b $c 中的最大值是"; echo "&lt;br /&gt;"; echo Math::Max3($a, $b, $c); ?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP给源代码加密的几种方法]]></title>
    <url>%2F2018%2F02%2F02%2FPHP%E7%BB%99%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[虽说分享是传统的美德，但我们有时候辛辛苦苦写一些程序只是为了卖点小钱，挣点辛苦费，也防止有些没有道德的人倒卖，所以我们不得不对我们的程序进行加密，以下我们来介绍一下如何通过PHP的自定义函数来加密我们的PHP源代码. 方法一：123456789101112131415161718192021222324&lt;?php function encode_file_contents($filename) &#123; $type=strtolower(substr(strrchr($filename,'.'),1)); if ('php' == $type &amp;&amp; is_file($filename) &amp;&amp; is_writable($filename)) &#123; // 如果是PHP文件 并且可写 则进行压缩编码 $contents = file_get_contents($filename); // 判断文件是否已经被编码处理 $contents = php_strip_whitespace($filename); // 去除PHP头部和尾部标识 $headerPos = strpos($contents,'&lt;?php'); $footerPos = strrpos($contents,'?&gt;'); $contents = substr($contents, $headerPos + 5, $footerPos - $headerPos); $encode = base64_encode(gzdeflate($contents)); // 开始编码 $encode = '&lt;?php'."\n eval(gzinflate(base64_decode("."'".$encode."'".")));\n\n?&gt;"; return file_put_contents($filename, $encode); &#125; return false; &#125; //调用函数 $filename = 'dam.php'; encode_file_contents($filename); echo "OK,加密完成！" ?&gt; 方法二：1234567891011121314151617181920212223242526272829&lt;?php function RandAbc($length = "") &#123; // 返回随机字符串 $str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; return str_shuffle($str); &#125; $filename = 'index.php'; //要加密的文件 $T_k1 = RandAbc(); //随机密匙1 $T_k2 = RandAbc(); //随机密匙2 $vstr = file_get_contents($filename); $v1 = base64_encode($vstr); $c = strtr($v1, $T_k1, $T_k2); //根据密匙替换对应字符。 $c = $T_k1.$T_k2.$c; $q1 = "O00O0O"; $q2 = "O0O000"; $q3 = "O0OO00"; $q4 = "OO0O00"; $q5 = "OO0000"; $q6 = "O00OO0"; $s = '$'.$q6.'=urldecode("%6E1%7A%62%2F%6D%615%5C%76%740%6928%2D%70%78%75%71%79%2A6%6C%72%6B%64%679%5F%65%68%63%73%77%6F4%2B%6637%6A");$'.$q1.'=$'.$q6.'&#123;3&#125;.$'.$q6.'&#123;6&#125;.$'.$q6.'&#123;33&#125;.$'.$q6.'&#123;30&#125;;$'.$q3.'=$'.$q6.'&#123;33&#125;.$'.$q6.'&#123;10&#125;.$'.$q6.'&#123;24&#125;.$'.$q6.'&#123;10&#125;.$'.$q6.'&#123;24&#125;;$'.$q4.'=$'.$q3.'&#123;0&#125;.$'.$q6.'&#123;18&#125;.$'.$q6.'&#123;3&#125;.$'.$q3.'&#123;0&#125;.$'.$q3.'&#123;1&#125;.$'.$q6.'&#123;24&#125;;$'.$q5.'=$'.$q6.'&#123;7&#125;.$'.$q6.'&#123;13&#125;;$'.$q1.'.=$'.$q6.'&#123;22&#125;.$'.$q6.'&#123;36&#125;.$'.$q6.'&#123;29&#125;.$'.$q6.'&#123;26&#125;.$'.$q6.'&#123;30&#125;.$'.$q6.'&#123;32&#125;.$'.$q6.'&#123;35&#125;.$'.$q6.'&#123;26&#125;.$'.$q6.'&#123;30&#125;;eval($'.$q1.'("'.base64_encode('$'.$q2.'="'.$c.'";eval(\'?&gt;\'.$'.$q1.'($'.$q3.'($'.$q4.'($'.$q2.',$'.$q5.'*2),$'.$q4.'($'.$q2.',$'.$q5.',$'.$q5.'),$'.$q4.'($'.$q2.',0,$'.$q5.'))));').'"));'; $s = '&lt;?php '."\n".$s."\n".' ?&gt;'; //echo $s; // 生成 加密后的PHP文件 $fpp1 = fopen('temp_'.$filename, 'w'); fwrite($fpp1, $s) or die('写文件错误'); ?&gt; 方法三：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283&lt;?php class text_auth &#123; var $n_iter; function text_auth() &#123; $this-&gt;setIter(32); &#125; function setIter($n_iter) &#123; $this-&gt;n_iter = $n_iter; &#125; function getIter() &#123; return $this-&gt;n_iter; &#125; function encrypt($data, $key) &#123; $n = $this-&gt;_resize($data, 4); $data_long[0] = $n; $n_data_long = $this-&gt;_str2long(1, $data, $data_long); $n = count($data_long); if (($n &amp; 1) == 1) &#123; $data_long[$n] = chr(0); $n_data_long++; &#125; $this-&gt;_resize($key, 16, true); if ( '' == $key ) $key = '0000000000000000'; $n_key_long = $this-&gt;_str2long(0, $key, $key_long); $enc_data = ''; $w = array(0, 0); $j = 0; $k = array(0, 0, 0, 0); for ($i = 0; $i &lt; $n_data_long; ++$i) &#123; if ($j + 4 &lt;= $n_key_long) &#123; $k[0] = $key_long[$j]; $k[1] = $key_long[$j + 1]; $k[2] = $key_long[$j + 2]; $k[3] = $key_long[$j + 3]; &#125; else &#123; $k[0] = $key_long[$j % $n_key_long]; $k[1] = $key_long[($j + 1) % $n_key_long]; $k[2] = $key_long[($j + 2) % $n_key_long]; $k[3] = $key_long[($j + 3) % $n_key_long]; &#125; $j = ($j + 4) % $n_key_long; $this-&gt;_encipherLong($data_long[$i], $data_long[++$i], $w, $k); $enc_data .= $this-&gt;_long2str($w[0]); $enc_data .= $this-&gt;_long2str($w[1]); &#125; return $enc_data; &#125; function decrypt($enc_data, $key) &#123; $n_enc_data_long = $this-&gt;_str2long(0, $enc_data, $enc_data_long); $this-&gt;_resize($key, 16, true); if ( '' == $key ) $key = '0000000000000000'; $n_key_long = $this-&gt;_str2long(0, $key, $key_long); $data = ''; $w = array(0, 0); $j = 0; $len = 0; $k = array(0, 0, 0, 0); $pos = 0; for ($i = 0; $i &lt; $n_enc_data_long; $i += 2) &#123; if ($j + 4 &lt;= $n_key_long) &#123; $k[0] = $key_long[$j]; $k[1] = $key_long[$j + 1]; $k[2] = $key_long[$j + 2]; $k[3] = $key_long[$j + 3]; &#125; else &#123; $k[0] = $key_long[$j % $n_key_long]; $k[1] = $key_long[($j + 1) % $n_key_long]; $k[2] = $key_long[($j + 2) % $n_key_long]; $k[3] = $key_long[($j + 3) % $n_key_long]; &#125; $j = ($j + 4) % $n_key_long; $this-&gt;_decipherLong($enc_data_long[$i], $enc_data_long[$i + 1], $w, $k); if (0 == $i) &#123; $len = $w[0]; if (4 &lt;= $len) &#123; $data .= $this-&gt;_long2str($w[1]); &#125; else &#123; $data .= substr($this-&gt;_long2str($w[1]), 0, $len % 4); &#125; &#125; else &#123; $pos = ($i - 1) * 4; if ($pos + 4 &lt;= $len) &#123; $data .= $this-&gt;_long2str($w[0]); if ($pos + 8 &lt;= $len) &#123; $data .= $this-&gt;_long2str($w[1]); &#125; elseif ($pos + 4 &lt; $len) &#123; $data .= substr($this-&gt;_long2str($w[1]), 0, $len % 4); &#125; &#125; else &#123; $data .= substr($this-&gt;_long2str($w[0]), 0, $len % 4); &#125; &#125; &#125; return $data; &#125; function _encipherLong($y, $z, &amp;$w, &amp;$k) &#123; $sum = (integer) 0; $delta = 0x9E3779B9; $n = (integer) $this-&gt;n_iter; while ($n-- &gt; 0) &#123; $y = $this-&gt;_add($y, $this-&gt;_add($z &lt;&lt; 4 ^ $this-&gt;_rshift($z, 5), $z) ^ $this-&gt;_add($sum, $k[$sum &amp; 3])); $sum = $this-&gt;_add($sum, $delta); $z = $this-&gt;_add($z, $this-&gt;_add($y &lt;&lt; 4 ^ $this-&gt;_rshift($y, 5), $y) ^ $this-&gt;_add($sum, $k[$this-&gt;_rshift($sum, 11) &amp; 3])); &#125; $w[0] = $y; $w[1] = $z; &#125; function _decipherLong($y, $z, &amp;$w, &amp;$k) &#123; $sum = 0xC6EF3720; $delta = 0x9E3779B9; $n = (integer) $this-&gt;n_iter; while ($n-- &gt; 0) &#123; $z = $this-&gt;_add($z, -($this-&gt;_add($y &lt;&lt; 4 ^ $this-&gt;_rshift($y, 5), $y) ^ $this-&gt;_add($sum, $k[$this-&gt;_rshift($sum, 11) &amp; 3]))); $sum = $this-&gt;_add($sum, -$delta); $y = $this-&gt;_add($y, -($this-&gt;_add($z &lt;&lt; 4 ^ $this-&gt;_rshift($z, 5), $z) ^ $this-&gt;_add($sum, $k[$sum &amp; 3]))); &#125; $w[0] = $y; $w[1] = $z; &#125; function _resize(&amp;$data, $size, $nonull = false) &#123; $n = strlen($data); $nmod = $n % $size; if ( 0 == $nmod ) $nmod = $size; if ($nmod &gt; 0) &#123; if ($nonull) &#123; for ($i = $n; $i &lt; $n - $nmod + $size; ++$i) &#123; $data[$i] = $data[$i % $n]; &#125; &#125; else &#123; for ($i = $n; $i &lt; $n - $nmod + $size; ++$i) &#123; $data[$i] = chr(0); &#125; &#125; &#125; return $n; &#125; function _hex2bin($str) &#123; $len = strlen($str); return pack('H' . $len, $str); &#125; function _str2long($start, &amp;$data, &amp;$data_long) &#123; $n = strlen($data); $tmp = unpack('N*', $data); $j = $start; foreach ($tmp as $value) $data_long[$j++] = $value; return $j; &#125; function _long2str($l) &#123; return pack('N', $l); &#125; function _rshift($integer, $n) &#123; if (0xffffffff &lt; $integer || -0xffffffff &gt; $integer) &#123; $integer = fmod($integer, 0xffffffff + 1); &#125; if (0x7fffffff &lt; $integer) &#123; $integer -= 0xffffffff + 1.0; &#125; elseif (-0x80000000 &gt; $integer) &#123; $integer += 0xffffffff + 1.0; &#125; if (0 &gt; $integer) &#123; $integer &amp;= 0x7fffffff; $integer &gt;&gt;= $n; $integer |= 1 &lt;&lt; (31 - $n); &#125; else &#123; $integer &gt;&gt;= $n; &#125; return $integer; &#125; function _add($i1, $i2) &#123; $result = 0.0; foreach (func_get_args() as $value) &#123; if (0.0 &gt; $value) &#123; $value -= 1.0 + 0xffffffff; &#125; $result += $value; &#125; if (0xffffffff &lt; $result || -0xffffffff &gt; $result) &#123; $result = fmod($result, 0xffffffff + 1); &#125; if (0x7fffffff &lt; $result) &#123; $result -= 0xffffffff + 1.0; &#125; elseif (-0x80000000 &gt; $result) &#123; $result += 0xffffffff + 1.0; &#125; return $result; &#125; &#125; ?&gt; 使用方法参考如下：// 加密过程view sourceprint? $text_file = S_ROOT . './456.php'; $str = @file_get_contents($text_file); require_once S_ROOT . "./text_auth.php"; $text_auth = new text_auth(64); $str = $text_auth-&gt;encrypt($str, "qianyunlai.com"); $filename = S_ROOT . './789.php'; // 加密后的文本为二进制，普通的文本编辑器无法正常查看 file_put_contents($filename, $str); // 解密过程view sourceprint?01 $text_file = S_ROOT . './789.php'; $str = @file_get_contents($text_file); require_once S_ROOT . "./text_auth.php"; $text_auth = new text_auth(64); $str = $text_auth-&gt;decrypt($str, "qianyunlai.com"); $filename = S_ROOT . './456.php'; file_put_contents($filename, $str); 该方法可以对文本的内容进行 二进制加密 与 解密。 以上几种方法各有各的优点和用处，大家也选择使用]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker的基本操作]]></title>
    <url>%2F2018%2F01%2F31%2FDocker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[今天是公司2018年的年会，地点定在渝中区大礼堂，下午1点30开始，上午几乎所有的小伙伴都按捺不住自己内心澎湃的心一心准备参加公司的年会，不知道是不是做程序员做久了，还是说早已习惯了公司的”套路”，不觉得年会有什么新鲜感和吸引我的地方，当然说句实话，年会对我吸引最大的肯定是抽奖环节，据说今年的终极大奖是现金10万；趁着这么还有点时间，更新下自己的博客吧使用Docker还是蛮久的了，但对于我来时，基本都是针对于开发搭建环境使用，所以也就只会一些基本的使用，要想看深入讲解的，请绕道咯。 Docker简介DockerDocker是一个开源平台，用于自动化部署应用，以通过快捷的途径在称之为容器的轻量级软件层下打包、发布和运行这些应用。它使得应用平台独立，因为它扮演了Linux上一个额外的操作系统级虚拟化的自动化抽象层。它通过其组件cgroups和命名空间利用Linux内核的资源分离特性，达到避免虚拟机开销的目的。它使得用于部署和扩展web应用、数据库和后端服务的大规模构建组件无需依赖于特定的堆栈或供应者。 容器所谓的容器，就是那些创建自Docker镜像的软件层，它包含了独立的Linux文件系统和开箱即用的应用程序。如果我们有一个在机器中运行着的Docker容器，并且想要备份这些容器以便今后使用，或者想要迁移这些容器，那么，本教程将帮助你掌握在Linux操作系统中备份、恢复和迁移Docker容器的方法 使用及介绍操作命令显示docker系统信息1docker info 镜像搜索1docker search php 获取镜像1docker pull richarvey/nginx-php-fpm (需要哪个就pull哪个) 导入本地镜像1docker load &gt; ~/Users/xiexiang/Downloads/[镜像名] 查看镜像1docker images 显示镜像的历史1docker history 删除镜像1docker rmi -f richarvey/nginx-php-fpm (带f据说不会残留垃圾) 创建容器1docker run -d -p 80:80 --name php-zzgg-un -v /Users/xiexiang/myproject/bajieke:/var/www/html registry.alauda.cn/neucloud/nginx-php-fpm:latest 查看容器(全部)1docker ps -a 查看已运行容器1docker ps 删除容器1docker rm -f [容器id] 进入到容器1docker exec -it [容器名] bash 启动容器1docker start [容器名] 停止容器1docker stop [容器名] 重启容器1docker restart [容器名] 容器的导出导入功能1、停止容器(也可以不停止，只要下一步commit成功即可)1docker stop [容器名] 2、将容器commit为镜像 12345docker commit ec1f968cc0d0 php-zzgg-un (容器id 自定义镜像名)```` 查看生成的镜像````phpdocker images 3、save镜像为tar文件 1docker save -o /Users/xiexiang/Downloads/php-zzgg-un.tar php-zzgg-un 4、将tar文件scp到 目标docker主机 1scp php-zzgg-un.tar root@10.45.7.197:/docker 5、导入本地镜像 docker load /Users/xiexiang/Downloads/php-zzgg-un.tar]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建的博客如何给文章分类（NEXT主题）]]></title>
    <url>%2F2018%2F01%2F25%2Fhexo%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E7%BB%99%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB%EF%BC%88NEXT%E4%B8%BB%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[tags：12345tags: - 前端- hexocategories: - 前端 在博客根目录输入1hexo new page tags 打开 tags/index.md ，并改成：1234title: 标签date: 日期type: "tags"comments: false 分类（同理）1hexo new page categories 打开category/index.md，改为：1234title: 分类date: 日期type: "categories"comments: false]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程即时修改微信菜单]]></title>
    <url>%2F2018%2F01%2F24%2F%E8%BF%9C%E7%A8%8B%E5%8F%8A%E6%97%B6%E4%BF%AE%E6%94%B9%E5%BE%AE%E4%BF%A1%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[场景： 某天程序员A加班加点完成了本次微信项目的迭代工作，在使用全身解数之后终于盼来了上线的等待，当然，后面也是成功上线了，但是项目经理在看过线上项目之后，才发现程序员A在微信后台修改的操作菜单并没有生效，当然程序员A也知道，这个生效要等一小时左右，但是项目经理急了，’我马上要给客户看，怎么能等待生效’。 这是一个线上执行的单文件，如有需要拆分成各个板块形成方法，可以自行去改。直接执行以下代码能即时修改微信菜单，比微信后台修改操作快很多。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118$appid = "xxxxxxx"; //微信appid$appsecret = "xxxxxxxxxxx"; //微信secret_id$url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$appid&amp;secret=$appsecret";$host = "http://xxxxxx.com"; //站点域名$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$output = curl_exec($ch);curl_close($ch);$jsoninfo = json_decode($output, true);$access_token = $jsoninfo["access_token"];header("Content-type: text/html; charset=utf-8");//创建菜单function createMenu($data, $access_token)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, "https://api.weixin.qq.com/cgi-bin/menu/create?access_token=".$access_token); curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST"); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (compatible; MSIE 5.01; Windows NT 5.0)'); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_AUTOREFERER, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $tmpInfo = curl_exec($ch); if (curl_errno($ch)) &#123; return curl_error($ch); &#125; curl_close($ch); return $tmpInfo;&#125; //获取菜单 function getMenu()&#123; return file_get_contents("https://api.weixin.qq.com/cgi-bin/menu/get?access_token=".ACCESS_TOKEN); &#125;//删除菜单 function deleteMenu()&#123; return file_get_contents("https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=".ACCESS_TOKEN); &#125; $data = array( "button" =&gt; array( array( "name"=&gt;urlencode("推广赚钱"), "sub_button"=&gt;array( array( "type"=&gt;"view", "name"=&gt;urlencode("首页"), "url"=&gt;$host."/default/index?needLogin=1&amp;agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("做任务"), "url"=&gt;$host."/proxy/taskHall?agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("提商机"), "url"=&gt;$host."/business/add?agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("推广爆品"), "url"=&gt;$host."/proxy/home?agent_r=agent_wx" ),array( "type"=&gt;"view", "name"=&gt;urlencode("推广店铺"), "url"=&gt;$host."/rebateshop/index?agent_r=agent_wx" ) ) ), array( "name"=&gt;urlencode("发展下级"), "sub_button"=&gt;array( array( "type"=&gt;"view", "name"=&gt;urlencode("发展下级"), "url"=&gt;$host."/invite/newinviteentershow?agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("管理下级"), "url"=&gt;$host."/partner/mypartner?agent_r=agent_wx" ) ) ), array( "name"=&gt;urlencode("我的"), "sub_button"=&gt;array( array( "type"=&gt;"view", "name"=&gt;urlencode("收益"), "url"=&gt;$host."/earnings/BalanceCommission?agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("我的店铺"), "url"=&gt;$host."/shop/detail?agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("个人中心"), "url"=&gt;$host."/home/ucenter?agent_r=agent_wx" ) ) ) ) ); //转义汉字 $data = json_encode($data); $data = urldecode($data);echo $data;echo "&lt;br&gt;\n";echo createMenu($data, $access_token);echo "\n";]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的 抽象类（abstract class）和 接口（interface）]]></title>
    <url>%2F2017%2F12%2F15%2FPHP%E4%B8%AD%E7%9A%84%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract%20class%EF%BC%89%E5%92%8C%20%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89%2F</url>
    <content type="text"><![CDATA[抽象类abstract class 抽象类是指在class前加了abstract关键字且存在抽象方法（在类方法function关键字前加了abstract关键字）的类。 抽象类不能被直接实例化。抽象类中只定义（或部分实现）子类需要的方法。子类可以通过继承抽象类并通过实现抽象类中的所有抽象方法，使抽象类具体化。 如果子类需要实例化，前提是它实现了抽象类中的所有抽象方法。如果子类没有全部实现抽象类中的所有抽象方法，那么该子类也是一个抽象类，必须在class前面加上abstract关键字，并且不能被实例化。 12345678910111213141516171819202122232425262728293031323334abstract class A &#123; /** 抽象类中可以定义变量 */ protected $value1 = 0; private $value2 = 1; public $value3 = 2; /** 也可以定义非抽象方法 */ public function my_print() &#123; echo "hello,world/n"; &#125; /** * 大多数情况下，抽象类至少含有一个抽象方法。抽象方法用abstract关键字声明，其中不能有具体内容。 * 可以像声明普通类方法那样声明抽象方法，但是要以分号而不是方法体结束。也就是说抽象方法在抽象类中不能被实现，也就是没有函数体“&#123;some codes&#125;”。 */ abstract protected function abstract_func1(); abstract protected function abstract_func2(); &#125; abstract class B extends A &#123; public function abstract_func1() &#123; echo "implement the abstract_func1 in class A/n"; &#125; /** 这么写在zend studio 8中会报错*/ //abstract protected function abstract_func2(); &#125; class C extends B &#123; public function abstract_func2() &#123; echo "implement the abstract_func2 in class A/n"; &#125; &#125; 如果像下面这样创建了一个继承自A的子类B，但是不实现抽象方法abstract_func()： 12345Class B extends A&#123;&#125;; ``` 那么程序将出现以下错误：```phpFatal error: Class B contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (A::abstract_func) 如果B实现了抽象方法abstract_func()，那么B中abstract_func()方法的访问控制不能比A中abstract_func()的访问控制更严格，也就是说：(1)如果A中abstract_func()声明为public，那么B中abstract_func()的声明只能是public，不能是protected或private(2)如果A中abstract_func()声明为protected，那么B中abstract_func()的声明可以是public或protected，但不能是private(3)如果A中abstract_func()声明为private，嘿嘿，不能定义为private哦！（Fatal error: Abstract function A::abstract_func() cannot be declared private） 接口interface 抽象类提供了具体实现的标准，而接口则是纯粹的模版。接口只定义功能，而不包含实现的内容。接口用关键字interface来声明。 interface是完全抽象的，只能声明方法，而且只能声明public的方法，不能声明private及protected的方法，不能定义方法体，也不能声明实例变量。然而，interface却可以声明常量变量。但将常量变量放在interface中违背了其作为接口的作用而存在的宗旨，也混淆了interface与类的不同价值。如果的确需要，可以将其放在相应的abstract class或Class中。 12345678910111213141516171819 interface iA &#123; const AVAR=3; public function iAfunc1(); public function iAfunc2(); &#125; echo iA:: AVAR; ``` * 任何实现接口的类都要实现接口中所定义的所有方法```php class E implements iA &#123; public function iAfunc1()&#123;echo "in iAfunc1";&#125; public function iAfunc2()&#123;echo "in iAfunc2";&#125; &#125; ``` 否则该类必须声明为abstract。```phpabstract class E implements iA&#123;&#125; 一个类可以在声明中使用implements关键字来实现某个接口。这么做之后，实现接口的具体过程和继承一个仅包含抽象方法的抽象类是一样的。一个类可以同时继承一个父类和实现任意多个接口。extends子句应该在implements子句之前。PHP只支持继承自一个父类，因此extends关键字后只能跟一个类名。 12345678910111213141516171819202122232425262728293031323334353637interface iB &#123; public function iBfunc1(); public function iBfunc2(); &#125; class D extends A implements iA,iB &#123; public function abstract_func1() &#123; echo "implement the abstract_func1 in class A/n"; &#125; public function abstract_func2() &#123; echo "implement the abstract_func2 in class A/n"; &#125; public function iAfunc1()&#123;echo "in iAfunc1";&#125; public function iAfunc2()&#123;echo "in iAfunc2";&#125; public function iBfunc1()&#123;echo "in iBfunc1";&#125; public function iBfunc2()&#123;echo "in iBfunc2";&#125; &#125; class D extends B implements iA,iB &#123; public function abstract_func1() &#123; parent::abstract_func1(); echo "override the abstract_func1 in class A/n"; &#125; public function abstract_func2() &#123; echo "implement the abstract_func2 in class A/n"; &#125; public function iAfunc1()&#123;echo "in iAfunc1";&#125; public function iAfunc2()&#123;echo "in iAfunc2";&#125; public function iBfunc1()&#123;echo "in iBfunc1";&#125; public function iBfunc2()&#123;echo "in iBfunc2";&#125; &#125; 接口不可以实现另一个接口，但可以继承多个 interface iC extends iA,iB{} class F implements iC { public function iAfunc1(){echo "in iAfunc1";} public function iAfunc2(){echo "in iAfunc2";} public function iBfunc1(){echo "in iBfunc1";} public function iBfunc2(){echo "in iBfunc2";} } 抽象类和接口的异同相同点： 两者都是抽象类，都不能实例化。 interface实现类及abstract class的子类都必须要实现已经声明的抽象方法。不同点： interface需要实现，要用implements，而abstract class需要继承，要用extends。 一个类可以实现多个interface，但一个类只能继承一个abstract class。 interface强调特定功能的实现，而abstract class强调所属关系。 尽管interface实现类及abstract class的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstractclass的子类可以有选择地实现。这个选择有两点含义：a) abstract class中并非所有的方法都是抽象的，只有那些冠有abstract的方法才是抽象的，子类必须实现。那些没有abstract的方法，在 abstract class中必须定义方法体；b) abstract class的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。 abstract class是interface与class的中介。abstract class在interface及class中起到了承上启下的作用。一方面，abstract class是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己的实例变量，以供子类通过继承来使用。 接口中的抽象方法前不用也不能加abstract关键字，默认隐式就是抽象方法，也不能加final关键字来防止抽象方法的继承。而抽象类中抽象方法前则必须加上abstract表示显示声明为抽象方法。 接口中的抽象方法默认是public的，也只能是public的，不能用private，protected修饰符修饰。而抽象类中的抽象方法则可以用public，protected来修饰，但不能用private。interface的应用场合 类与类之间需要特定的接口进行协调，而不在乎其如何实现。 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。abstract class的应用场合一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有： 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能 。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http中的referer]]></title>
    <url>%2F2017%2F11%2F24%2Fhttp%E4%B8%AD%E7%9A%84referer%2F</url>
    <content type="text"><![CDATA[安全培训中提到可以通过referer判断安全性，hackbar中也有一个enable referer的选项，则，这个referer到底是个什么角色？ 在http请求的Headers部分可见Referer. 1Referer http://www.baidu.com/s?tn=98835442_hao_pg&amp;ie=utf-8&amp;f=3&amp;wd=126.com&amp;oq=126.&amp;bs=126.com&amp;rsv_bp=1&amp;inputT=5799&amp;rsp=0 Http协议头中的Referer主要用来让服务器判断来源页面, 即用户是从哪个页面来的,通常被网站用来统计用户来源,是从搜索页面来的,还是从其他网站链接过来,或是从书签等访问,以便网站合理定位. Referer有时也被用作防盗链, 即下载时判断来源地址是不是在网站域名之内, 否则就不能下载或显示,很多网站,如天涯就是通过Referer页面来判断用户是否能够下载图片 当然,对于某些恶意用户,也可能伪造Referer来获得某些权限,在设计网站时要考虑到这个问题. 还可用做电子商务网站的安全，在提交信用卡等重要信息的页面用referer来判断上一页是不是自己的网站，如果不是，可能是黑客用自己写的一个表单，来提交，为了能跳过你上一页里的javascript的验证等目的。 但是注意不要把Rerferer用在身份验证或者其他非常重要的检查上，因为Rerferer非常容易在客户端被改变。 （火狐的一个插件RefControl修改Referer引用） 对浏览器来说,一般以下几种情况是不会发送Referer,因为可能有潜在的安全问题: 123456781.用户手动输入网址或是从收藏夹/书签中访问.2.页面从Https跳转到Http；应该是处于安全考虑，该点在RFC-2616中有说明；主流浏览器均遵守这个规则，比如IE、FF；但默认情况下Https到Https是会发送Referer的安全问题在于有可能把地址中含有的一些关于用户的敏感信息发送到其他恶意网站上.3、由于FF提供了很强大的自定义参数设置功能，所以我们可以通过about:config页面修改以下两个选项的默认设置：network.http.sendRefererHeader (default=2)设置Referer的发送方式，0为完全不发送，1为只在点击链接时发送，在访问页面中的图像什么的时候不发送，2为始终发送。 参考： http://blog.csdn.net/mutsinghua/article/details/5187595]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>referer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP编程]]></title>
    <url>%2F2017%2F11%2F23%2FPHP%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[PHP基本语法数组123456789101112131415161718192021222324252627282930313233343536array_chunk($array, $size): 将数组按size大小分为多个数组array_diff($a, $b): 比较数组的不同，可以用来判断两个数组是否相等，需要注意的是这里返回的是在array1中但是不在array2中的值，而不是两个的交集array_key_exists("key",$a) # 查看key是否存在于某个字典array_intersect($array1, $array2[,$array $...]) # 返回一个数组，该数组包含了所有在array1同时也出现在其他参数数组中的值array_merge() # 合并数组，相同的key直接覆盖array_merge_recursive() # 合并数组，相同的key不覆盖array_push($source, "red", "gree") # 给数组添加元素array_search(): 搜索一个key的索引，如果是二维的数组，那么就是通过value搜索keyarray_search(strtolower($search), array_map('strtolower', $array)): array_search忽略大小写array_slice($arr, 0, 1) # 数组分片array_sum($arr): 计算数组中所有值的和array_values($arr): 获取数组所有的value值 count()函数：输出数组的长度empty()函数：判断数组是否为空end() // 返回当前数组的最后一个值，需要注意的是这个函数不仅仅是返回最后一个值，还会把数组当前的指针指向最后一个数据explode(',', $str) # 将字符串分割为数组 implode(',', $arr) # 将数组拼接成字符串in_array('a', $a) # 查看数组是否存在某个元素json_encode($arr) # 数组转换城字符串list($a, $b) = [1, 2] # 分别赋值rsort(): 以降序对数组排序sort(); # 排序，可以给数组排序，会修改原来数组的值uasort($array, $cmp_function) # 定义对比函数进行排序unset(arr[1]): 删除数组元素# 数组遍历foreach($array as $value): 数组遍历foreach($array as $key =&gt; $value): 数组(字典)遍历 # 数组用于函数func(*list): 将数组作为函数的输入 # 在数组里面添加数组元素，在不确定key的情况下$arr = [];$arr['a'][] = 'a';$arr['a'][] = 'b'; 字符串PHP里面单引号和双引号确实有些地方的用法是不同的，比如匹配换行符的时候1234567891011121314151617181920212223242526272829json_decode(string, $assoc=false) # 将字符串转换为json对象,$assoc=true时返回array而不是objectlcfirst($str) # 将字符串首字母转换为小写mb_strlen($str, 'utf-8') # 求中文字符串长度mb_substr($str, $start, $length, 'utf-8'): 字符串分割，可以分割中文哟，如果要获得所有右边的，那么$length不用填或者填上NULL，如果版本不行那就是用功能弱一点的substrnl2br() # 将字符串中的\n转换成网页的换行符&lt;br&gt;sprintf() # 字符串格式化，需要注意的是，它不是用\转义，而是用的%来转义strlen() # 求字符串长度strpos('abc', 'a'); # 在字符串中查找第一次出现位置，没找到返回falsestr_repeat('abc', n) # 将字符串重复n次str_replace(搜索值，替换值，目标) # 字符串替换str_replace("\n", "", $content); # 去除换行符substr_count($haystack, $needle, [$offset, $length]); # 计算子字符串needle在字符串haystack中出现的次数trim($string); # 去除字符串前后的空白字符，如果要去除所有的字符只能使用preg_replace('/\s+/', '', $string)，这是stackoverflow上面给出的答案$a . $b . 'abc':字符串连接直接用点号explode(',', $str, [$limit]) # 字符串分割，第三个参数大于0表示限制分组数量，limit规定所返回的数组元素的个数，小于0时，返回包含除了最后的-limit个元素以外的所有元素的数组；0表示返回包含一个元素的数组array_map('strrev', explode('-', strrev($a), 2)) # 字符串分割，逆向iconv('utf-8', 'GBK', $data): 将字符编码从utf-8转换为GBKjoin("&amp;", $arr) # 拼接字符串parse_str('name=wang&amp;age=18'): 从查询字符串中解析到变量，可以得到$name和$age两个变量parse_url($url): 解析url成数组，与http_build_query()功能相反preg_replace('/user_id=\d+&amp;name=/', 'user_id=' . 1048 . '&amp;name=', $code): 正则替换preg_replace_callback('//', function($matches)&#123;return strtolower($matchs[0])&#125;: 执行一个正则表达式搜索并且使用一个回调函数进行替换preg_match('/Chongqing(?&lt;right&gt;.*)/', $string, $matches): 正则匹配，pattern参数前后必须加斜杠sprintf("sahgoiahg%s", $a): 格式化输出strtolower($str)/strtoupper($str): 大小写字符串ucfirst($str): 将字符串首字母大写ucwords($str): 将字符串每个单词首字母大写 str_replace(' ', '', lcfirst(ucwords(str_replace(['-', '_'], ' ', $str)))); # 字符串转换为驼峰命名法 数字1234567ceil()函数：向上取整rand(min, max)：产生随机数，不需要给初始值了现在intval($val): 字符串转整数，如果不是数字型字符串，那么转换会失败，失败后返回0，没错是0，mmpint ip2long(string $ip_address)：IP转换成整数值string long2ip(string $proper_address)：整数值转换成IPnumber_format(float $number) // 以千位分隔符方式格式化一个数字，返回字符串sprintf('%04d', 2) // 数字前补零 时间1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859time(): 获取当前时间戳strtotime(''): 字符串转换为时间戳gmdate("Y-m-d\TH:i:s\Z"): 获取GMT时区的时间$beginToday=mktime(0,0,0,date('m'),date('d'),date('Y')):获取今天开始时的时间戳$endToday=mktime(0,0,0,date('m'),date('d')+1,date('Y'))-1:获取今天结束时的时间戳$beginYesterday=mktime(0,0,0,date('m'),date('d')-1,date('Y'))：获取昨天开始时的时间戳$endYesterday=mktime(0,0,0,date('m'),date('d'),date('Y'))-1：获取昨天结束时的时间戳$beginLastweek=mktime(0,0,0,date('m'),date('d')-date('w')+1-7,date('Y'))：获取上周开始时的时间戳$endLastweek=mktime(23,59,59,date('m'),date('d')-date('w')+7-7,date('Y'))：获取上周结束时的时间戳$beginThismonth=mktime(0,0,0,date('m'),1,date('Y'))：获取本月开始时的时间戳$endThismonth=mktime(23,59,59,date('m'),date('t'),date('Y'))：获取本月结束时的时间戳# 单独获取当前的年、月、日、时、分、秒等date('Y-m-d H:i:s'); // 如果要单独获取或者修改格式，那么直接按照里面的格式修改即可# 输出指定格式date('Y-m-d H:i', time())# 时间的表示d: 月份中的第几天，有前导零的2位数字，01到31D: 星期中的第几天，文本表示，3个字母，Mon 到 Sunj: 月份中的第几天，没有前导零，1 到 31l:（“L”的小写字母），星期几，完整的文本格式 Sunday 到 SaturdayN: ISO-8601 格式数字表示的星期中的第几天（PHP 5.1.0 新加），1（表示星期一）到 7（表示星期天）S: 每月天数后面的英文后缀，2 个字符，st，nd，rd 或者 th。可以和 j 一起用w: 星期中的第几天，数字表示 0（表示星期天）到 6（表示星期六）z: 年份中的第几天 0 到 365星期 --- ---W ISO-8601 格式年份中的第几周，每周从星期一开始（PHP 4.1.0 新加的） 例如：42（当年的第 42 周）月 --- ---F 月份，完整的文本格式，例如 January 或者 March January 到 Decemberm 数字表示的月份，有前导零 01 到 12M 三个字母缩写表示的月份 Jan 到 Decn 数字表示的月份，没有前导零 1 到 12t 指定的月份有几天 28 到 31年 --- ---L 是否为闰年 如果是闰年为 1，否则为 0o ISO-8601 格式年份数字。这和 Y 的值相同，只除了如果 ISO 的星期数（W）属于前一年或下一年，则用那一年。（PHP 5.1.0 新加） Examples: 1999 or 2003Y 4 位数字完整表示的年份 例如：1999 或 2003y 2 位数字表示的年份 例如：99 或 03时间 --- ---a 小写的上午和下午值 am 或 pmA 大写的上午和下午值 AM 或 PMB Swatch Internet 标准时 000 到 999g 小时，12 小时格式，没有前导零 1 到 12G 小时，24 小时格式，没有前导零 0 到 23h 小时，12 小时格式，有前导零 01 到 12H 小时，24 小时格式，有前导零 00 到 23i 有前导零的分钟数 00 到 59&gt;s 秒数，有前导零 00 到 59&gt;u 毫秒 （PHP 5.2.2 新加）。需要注意的是 date() 函数总是返回 000000 因为它只接受 integer 参数， 而 DateTime::format() 才支持毫秒。 示例: 654321时区 --- ---e 时区标识（PHP 5.1.0 新加） 例如：UTC，GMT，Atlantic/AzoresI 是否为夏令时 如果是夏令时为 1，否则为 0O 与格林威治时间相差的小时数 例如：+0200P 与格林威治时间（GMT）的差别，小时和分钟之间有冒号分隔（PHP 5.1.3 新加） 例如：+02:00T 本机所在的时区 例如：EST，MDT（【译者注】在 Windows 下为完整文本格式，例如“Eastern Standard Time”，中文版会显示“中国标准时间”）。Z 时差偏移量的秒数。UTC 西边的时区偏移量总是负的，UTC 东边的时区偏移量总是正的。 -43200 到 43200完整的日期／时间 --- ---c ISO 8601 格式的日期（PHP 5 新加） 2004-02-12T15:19:21+00:00r RFC 822 格式的日期 例如：Thu, 21 Dec 2000 16:01:07 +0200U 从 Unix 纪元（January 1 1970 00:00:00 GMT）开始至今的秒数 参见 time() Carbon时间处理第三方库1Carbon::parse('2017-08-25 18:18:18'); # 不用指定格式即可将时间字符串自动转换为Carbon对象 文件操作12345678$fp = fopen("test", "r") or die("Unable to open file!"); # 打开文件$fp = fopen('test', 'w') # 写入fread($fp,filesize("webdictionary.txt")); # 读取指定大小的内容fgetc($fp) # 读取一个字符fgets($fp) # 读取一行feof($fp) # 判断指针是否指向文件尾了fwrite($fp, 'haofly') # 写入字符串到文件fclose($fp); # 关闭文件 函数/类/对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# public, private, projtected的区别:public # 权限最多，可以内部调用，实例调用protected # 受保护类型，用于本类和继承类调用private # 私有类型，只有在本类中使用 # 对象的序列化和反序列化serialize()unserialize() # 一些自省(反射)方法func_get_args() # 获取当前方法所有的参数get_class(className) # 取得当前语句所在的类名get_class_methods(className) # 取得相应class所包含的所有的方法名get_class_vars(clasName) # 取得相应class所包含的所有的变量名get_object_vars($object) # 获取类或者对象的属性，返回数组property_exists($object, $key) # 类或者对象是否存在某个属性setAttribute($name, $value) # 设置函数的属性或者直接设置函数的内部变量$this-&gt;&#123;$key&#125; = $value # 给类动态添加属性$this-&gt;&#123;$key&#125; # 返回对象指定的属性# 根据类名知道类的定义文件$reflector = new ReflectionClass('className');echo $reflector-&gt;getFileName();# 标准嘞StdClass$obj-&gt;value # 直接获取其内部的变量 # trait: 一种代码复用机制，从基类继承的成员会被trait插入的成员所覆盖，优先顺序是来自当前类的成员覆盖了trait的方法，而trait则覆盖了被继承的方法。这是为了弥补PHP单继承的局限# 例如可以写一个单例:trait SingleInstance&#123; static private $instance = null; static public function getInstance()&#123; if (!self::$instance) &#123; self::$instance = new static(); &#125; return self::$instance; &#125;&#125;# 在其他类里面只需要use SingleInstance就行了。再比如，文档里面的例子&lt;?phpclass Base &#123; public function sayHello() &#123; echo 'Hello '; &#125;&#125;trait SayWorld &#123; public function sayHello() &#123; parent::sayHello(); echo 'World!'; &#125;&#125;class MyHelloWorld extends Base &#123; use SayWorld;&#125;$o = new MyHelloWorld();$o-&gt;sayHello(); // 输出的是Hello World?&gt; 发送CURL请求注意：使用CURL之前一定要先确定服务器是否已经安装php的curl扩展，如果没有，可能会报奇怪的错误，安装完扩展后记得重启php进程。123456789101112131415161718192021$ch = curl_init(); // 初始化curlcurl_setopt(); // 设置参数curl_setopt($ch, CURLOPT_URL, 'url'); // 设置URLcurl_setop($ch, CURLOPT_POST, true); // 发送POST请求curl_setop($ch, CURL_POSTFIELDS, $data); // POST的数据curl_setop($ch, CURLOPT_RETURNTRANSFER, true); // 获取返回结果，如果不加这个，那么$result=true$result = curl_exec($ch); // 执行curl请求curl_getinfo($ch, CURLINFO_HTTP_CODE) // 获取http_code curl_setopt($curlHandle, CURLOPT_HTTPHEADER, ['Accept: application/json']); // 添加HTTP头curl_close($ch); // 关闭连接# 如果要通过CURL 上传文件，那么需要这样对$data进行处理if (function_exists('curl_file_create')) &#123; // php 5.6+ $cFile = curl_file_create($scriptPath);&#125; else &#123; // $cFile = '@' . realpath($scriptPath);&#125;$data = ['file' =&gt; $cFile];# 获取curl所有参数所代表的常量值$arr = get_defined_constants(true);var_dump($arr['curl']); WEB程序1234567891011$_SERVER['REQUEST_METHOD'] # 返回数据提交的方式，GET、POST等$_SERVER["SERVER_PORT"] # 获取端口$_SERVER['HTTP_HOST'] # 获取域名或主机地址$_SERVER['SERVER_NAME'] # 获取域名或主机名$_SERVER["REQUEST_URI"] # 获取域名后的详细地址$_SERVER['PHP_SELF'] # 获取PHP文件名$_SERVER["QUERY_STRING"] # 获取网址后的参数$_SERVER['HTTP_REFERER'] # 获取来源urlparse_str(file_get_contents("php://input"),$post_vars); # 获取PUT数据getallheaders # 获取请求头error_log('message') # 把错误信息发送到web服务器的错误日志，或者到一个文件里，有长度限制 MySQL1mysql_errno(): # 打印SQL出错信息 异常处理12345try&#123; throw new Exception('soahg');&#125;catch(Exception $e)&#123; echo $e-&gt;getMessage();&#125; PHP命令行1php --ini # 查看php的配置文件 帮助函数12345678910111213141516171819gettype(): 获取变量类型$obj instanceof A # 判断对象是否属于某个类，不过判断是不是数组只能用is_array() # 判断是否是数组is_string() # 判断是否是字符串is_object() # 判断是否是objectis_bool() # 是否是布尔值is_int() # 是否是整数is_integer()# 是否是整数is_float() # 是否是浮点数is_real() # 是否是实数is_numeric # 是否是数字或者数字字符串interface_exists() # 检查接口是否已经定义class_exists() # 检查类是否已经定义 PHP_INT_MAX # 最大整数PHP_INT_MIN # 最小整数min($value1, $value2...) # 选出最小值，最大值max同理min([$value1, $value2,...]) # 选出最小值，最大值max同理 hash_hmac(算法名, 明文, 盐) # hash加密函数，可以选定加密算法，例如hash_hmac('sha1', 'mingwen', 'salt') @操作符: 错误控制运算符，写在一行的前面，可以控制改行不输出warning信息或错误信息 var_dump(变量名)：打印变量，这个函数还会打印变量的类型可以把一个变量的各个部分全部信息输出，包括每个部分的数据类型和长度等信息，但是默认情况下，输出有限制，如果层数深了或者数据长了可能会表示成省略号，可以在C:\wamp\bin\apache\apache2.4.9\bin\php.ini里面修改xdebug节点，添加如下内容 12xdebug.var_display_max_data=512xdebug.var_display_max_depth=5 另外，将var_dump的输出转换为一个字符串以便web前端显示，可以这样用：12345ob_start();var_dump($data);$result = ob_get_clean();# 或者用另外的函数var_export: 输出或返回一个变量的字符串表示 file_get_contents：获取文件或http内容，如果要从http获得json数据可以直接使用它 isset()：查看某个变量是否已经被定义，未赋值或赋NULL都会返回false @header(‘Content-type: text/html;charset=UTF-8’);PHP文件中添加中文支持，在脚本开始的地方添加给行即可 多行输出：其中最后一个EOF必须写在一行的开头，且里面如果要用变量这样用{ $php_var }echo &lt;&lt;&lt;EOF print_r:打印关于变量的易于理解的信息。如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。这点在调试的时候很有用 类的方法尽量写成static，速度比public快 composer包管理require是指在生产环境中必须的包，而require-dev则是开发的时候要用而生产环境无需用的包，常用命令:123456789composer config --list # 列出当前所有的配置composer show # 获取所有安装的包的列表composer require package_name --dev # 安装包，并将其写入composer.json的require-dev中去composer remove package_name # 移除包composer config -g repo.packagist composer https://packagist.phpcomposer.com # 更换为国内的源# 忽略ssl证书验证composer config --global disable-tls truecomposer config --global secure-http false"package/ppkg": "2.7.*@beta" # 安装beta版 autoloadautoload，可以预加载类，自动索引所有的类，能够加快依赖的索引速度。但是autoload并不是实时更新的，如果发现vendor/composer/autoload_classmap.php中的类与你预想的有冲突，那么就需要更新一下了：composer dump-autoload。 在composer.json中有四种自动加载类型: classmap: development相关的 123&#123; "classmap": ["src/"] # 这样composer就会读取这个文件夹下所有的文件，然后再vendor/composer/autoload_classmap.php中将所有的class的namespace+classname生成一个key=&gt;value的数组&#125; psr-0: 已经被弃用 psr-4: 一般用于项目代码的自动加载 files: helper相关的Extension扩展管理12var_dump(extension_loaded('curl')); // 查看是否安装某个模块var_dump(get_loaded_extensions()); // 查看安装了哪些模块 TroubleShooting Call to undefined function getallheaders()版本问题，如果是老版本可以使用如下代码代替 12345678910111213if (!function_exists('getallheaders')) &#123; function getallheaders() &#123; foreach($_SERVER as $key=&gt;$value) &#123; if (substr($key,0,5)=="HTTP_") &#123; $key=str_replace(" ","-",ucwords(strtolower(str_replace("_"," ",substr($key,5))))); $out[$key]=$value; &#125;else&#123; $out[$key]=$value; &#125; &#125; return $out; &#125; &#125; 回掉函数中访问外部变量方法一：使用类的静态变量方法二：使用use语法 123$dt-&gt;each(function() use($bianliang) &#123; echo $bianliang;&#125;); Error while reading line from server这是在使用predis时报的错误，原因是没有设置read_write_timeout=－1使redis保持永久连接，否则会在一定时间后断开连接 isset和empty判断变量是否存在的问题。都不能用于静态数组变量的判断，最好用array_key_exists 原文摘至：http://haofly.net/php/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《维和步兵营》观后感]]></title>
    <url>%2F2017%2F11%2F23%2F%E3%80%8A%E7%BB%B4%E5%92%8C%E6%AD%A5%E5%85%B5%E8%90%A5%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[《维和步兵营》看完之后给我给我的感触和启发都颇深，脑子里久久都回荡着里面的每一个场景，不得不说是一部好的电视剧，从《士兵突击》到《我是特种兵》系列到《维和步兵营》不得不让我爱上那种军人气概、军人气节、军人情怀。天气转凉，蜷缩在被窝里，写点观后感，一部电视剧也是一种经历，记录下此刻的心境。 不是每个人生下来就拥有和平的生活，也不是每个人生下来就该面临残酷的社会境况。当我们在一个和平的国度每天上下班努力打拼赚钱养家，回家能洗上热乎乎的热水澡，晚上抱着媳妇儿孩子睡觉，工作之余出门旅游度假时，或者其他国家的人正在面临着战争、饥荒、疾病、死亡；我们生活在和平的国家，能谈理想、能享受生活，或许他们是否能活过明天都还是未知数。这不电视剧里面有很多都是真实的写照，部落之间的冲突与矛盾，政府军与反政府军的冲突，恐怖分子与资源争夺的冲突，这些都是真实发生在遥远的非洲，非洲人民面临战争、面临饥荒、面临贫穷与落后，里面有多个镜头是他们在马路浑浊的小水沟里取水的场景，看着着实辛酸；小孩们很多都是衣不遮体，很多的小孩和大人为了生活，不得不拿起手中的枪参加杀戮。 《维护步兵营》讲述的是一群训练有素的中国特种部队（隶属于中国特种部队红一连，红一连历史悠久、战功卓绝，跟随毛泽东参加过秋收起义，也称秋收起义红一连）奔赴非洲，维护世界和平的一段故事，在里面，我们看到了中国军人不畏艰难，有勇有谋，敢流血、敢牺牲的英勇精神；他们奔赴远方，头戴蓝盔，走向世界，维护和平。观影过程中不由自主留下四次泪水，有激动的泪水、感人的泪水、也有愤概的泪水，他们不是以个人、集团军的名义走向世界，他们是以国家荣誉而走向世界，13亿中国人是他们坚实的后盾，流血流泪，哪怕是牺牲，他们也只是默默的付出，不求回报。 人物描述 戈睿：参军前，一个耀武扬威的公子哥，仗着自己家里有点钱，不可一世，整天都在想给身边的人证明点什么，却什么也没能证明；参军之后，也是一个‘买一赠一’的货，随着机缘来到特种部队，并且进入到红一连的维护部队训练营，毕竟年轻，桀骜不顺，吃过苦头，但还是觉得自己了不起，成天与薛三桥斗嘴，去导非洲之后还与外国士兵为争夺郑百合大打出手；当然，行事正义，为人大方。对于他非常特别的转变应该在薛三桥死后，真正的成熟不少，沉稳、执着，特别是在他给她妈打电话的那一刻，我不忍热泪盈眶。 薛三桥：记忆最深刻的当然是他的口头禅：“我不是针对谁，我也不是挑事的人”，一直都是戈睿的死对头，每次听到他说这句话我都想笑，有了他和戈睿，军营多了很多的欢声笑语、军营氛围；在他被炸弹击中倒下的那一刻，我又重新理解了战友之间的情怀，哪怕不是薛三桥，有可能其他的人也上了，因为在我的理解下，那是一种本能的反应，谁都有可能冲上去，就在冲上去的那一刻，倒下就再也没起来，头上都炸了几个窟窿。 戈向东：商人、退伍军人，有着浓烈的军人情结，不管是在利比亚还是非洲，都为中国军人给予不少的帮助，在他看来军民早就是一家人，同时他的身影，也体现了中国人民对非洲人民作出的贡献与付出，不畏战争，不畏死亡，为世界和平事业奉献一份力量。 岳东明：从《我是特种兵》里面的身影一直到这部戏，给我的感觉都是一个特别刚直不阿、不折不扣的军人，他的言语很有气势也很能打动人，我相信不仅仅是演戏，生活中也是一个很受欢迎的人。他在剧中的角色可以说是一个关键人物，在两连队人重组之后几乎到了快散架的时候，是他的出现稳定了全局；在赵忠宝失意决心离开部队退伍的时候，是他的出现，重新燃起赵忠宝那股战斗热情；在林浩楠决心离开连长一职，走向司令部获取更多情报时，是他的出现，重新带领整个连队继续战斗。他的角色可以说文武双全，有战略思想，同时也有政治情怀，剧中最让他无助的是在他还在部落战争维和的时候，他的母亲却悄然离开了人世，相隔万里，那种思念之痛可想而知；在剧中后半部分的时候，他却因为保护几个孩子，被恐怖分子的火箭弹击中，从此永远离开了红一连。家里有老婆，还有两个孩子，面对这样的情况编剧是不是有点太残忍了。 罗汉：罗汉这个演员还是在《我是特种兵》里面认识的，帅气、冷酷的形象让人记忆尤新，在本剧里面扮演的是林浩楠的助手，参演过很多的电视剧，可能以后也不会是男一号，但是他的人物个性鲜明，演技到位，我现在看这种电视剧有个情结，凡是有特种兵里面的人物，我都会继续看下去。 田爽：饰演者孙晶晶，在里面是个不折不扣的大美女，身材火辣性感，在本剧中为戈向东在非洲企业中的得力经理。。。 未完待续。。。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
