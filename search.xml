<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用JSON获取Bing每日背景图片]]></title>
    <url>%2F2018%2F02%2F02%2F%E7%94%A8JSON%E8%8E%B7%E5%8F%96Bing%E6%AF%8F%E6%97%A5%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[经过访问BING的网址最终发现，bing中文网一直在提供每日更新背景图片壁纸的json数据.访问网址：http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1根据上面地址的结构，我暂时研究到就三项属性有效，他们分别是: format，非必要。我理解为输出格式，不存在或者不等于js，即为xml格式，等于js时，输出json格式； idx，非必要。不存在或者等于0时，输出当天的图片，-1为已经预备用于明天显示的信息，1则为昨天的图片，idx最多获取到前16天的图片信息；* n，必要。这是输出信息的数量，比如n=1，即为1条，以此类推，至多输出8条；* *号注释：此处我们要注意的时，是否正常的输出信息，与n和idx有关，通过idx的值，我们就可以获得之前bing所使用的背景图片的信息了。 提供一个我正在用json转php，调用图片地址的方法:123$str = file_get_contents('http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1'); $array = json_decode($str); $imgurl = $array-&gt;&#123;"images"&#125;[0]-&gt;&#123;"url"&#125;; 亲测方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * 从bing上获取背景图片 */class model_op_bing extends components_basemodel&#123; const CACHE_BING_PIC = "op.bing.%s"; /** * @var Cache_MemCache */ protected $cache = null; public function __construct($pkid = false) &#123; parent::__construct($pkid); $this-&gt;cache = SCache::getCacheEngine("Memcache"); $this-&gt;cache-&gt;init(array('servers' =&gt; lib_Constant::$MEMCACHE_SERVERS)); &#125; public function getBackground($isForce=false) &#123; $cacheKey = sprintf(self::CACHE_BING_PIC, date("Y_m_d",time())); if ( $this-&gt;cache-&gt;get($cacheKey) &amp;&amp; false == $isForce ) &#123; return $this-&gt;cache-&gt;get($cacheKey); &#125; $picSuffix = 'http://cn.bing.com'; $result = file_get_contents( sprintf('%s%s', $picSuffix, '/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1') ); $bing = json_decode($result); $imgurl = $bing-&gt;&#123;"images"&#125;[0]-&gt;&#123;"url"&#125;; $imgurl = false === strpos($picSuffix, $imgurl) ? sprintf('%s%s', $picSuffix, $imgurl) : $imgurl; $type = pathinfo($imgurl, PATHINFO_EXTENSION); $data = file_get_contents($imgurl); $base64 = 'data:image/' . $type . ';base64,' . base64_encode($data); $this-&gt;cache-&gt;set($cacheKey, $base64, 43200); return $base64; &#125;&#125; 调用方：12$params['backgroundImg'] = (date('Ymd') == '20161208' || date('Ymd') == '20161209') ? "/assets/op/img/1208_index.jpg" : $bingModel-&gt;getBackground((!empty($_GET['update'])) ? true : false);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个重要函数（获取无限极菜单+批量排序）]]></title>
    <url>%2F2018%2F02%2F02%2F%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%EF%BC%88%E8%8E%B7%E5%8F%96%E6%97%A0%E9%99%90%E6%9E%81%E8%8F%9C%E5%8D%95-%E6%89%B9%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[以下两个函数是自己在接触PHP的时候学到的，这里做一下记录只是为了怀念那个时候对于行业的那种陌生感和探索欲望，这两个函数虽然不是很难，但是用的地方不少，比如获取目录树，可以用在对类目的管理、评论等无限级的地方都可以用，话不多说，请看代码。 获取目录树1234567891011121314151617181920212223242526272829303132333435363738/*** 得到菜单栏目树* @author xiexiang 2016-03-17* @params eg $map = "name = 'xiexiang'" //查询条件**/public function getMenu($map )&#123; //实例化数据表menu $menu = new model_op_menu() ; $order = "ORDER BY level ASC,sort DESC"; $menu_list = $menu-&gt; select($map , '', '', $order , '', ''); $mod_list = $menu_list-&gt; items; if (!$mod_list || empty( $mod_list)) &#123; return false; &#125; $tmp = array() ; $address = array() ; //父级地址 foreach ($mod_list as $k =&gt; $v) &#123; $id = $v[ 'id']; if ($v ['level'] &lt;= 1) &#123; //一级 $tmp [$id] = $v; $address [$id] = &amp; $tmp[$id ]; &#125; else &#123; //子集 $pid = $v[ 'pid']; if (!$address[ $pid]['child' ]) &#123; $address[ $pid]['child' ] = array() ; &#125; $address [$pid][ 'child'][$id ] = $v; $address [$id] = &amp; $address[$pid ]['child'][ $id]; &#125; &#125; return $tmp;&#125; 批量排序123456789101112131415161718192021222324252627282930313233/*** 批量排序*/public function pagesort()&#123; //异常插入 try &#123; $sort = lib_BaseUtils::getStr( $_GET['sort' ]); if (empty( $sort)) &#123; throw new Exception( '请选择需要排序的数据！' , 0) ; &#125; foreach ( $sort as $k =&gt; $v) &#123; if (!is_numeric( $k) || !is_numeric($v )) &#123; continue; &#125; $sql_bat_sort .= " WHEN &#123; $k&#125; THEN &#123;$v&#125; "; $sql_ids .= ',' . $k; &#125; $menu = new model_op_menu() ; $sql = "UPDATE op_menu SET sort= CASE id " . $sql_bat_sort . " END WHERE id IN (" . trim($sql_ids , ', ') . ")"; $menu -&gt;query( $sql); throw new Exception('批量排序成功！', 1 ); &#125; catch (Exception $e ) &#123; return $this -&gt;printmsg( $e-&gt;getMessage (), $e -&gt;getCode()) ; &#125;&#125; 巧办法上诉的获取目录树也可以用通过更加简单的办法来实现，在数据库设计合理的情况下，可以使用递归的方式来做。1234567891011121314151617181920/** * - 得到树形处理后的分类列表 * @param int $pid * @param array $result * @param int $space * @return array */ public function getTree($pid=0,&amp;$result=[],$space=0) &#123; $space+=2; $parents = Category::where('cate_pid',$pid)-&gt;orderBy('cate_order','DESC')-&gt;get(); foreach ($parents as $key =&gt; $val)&#123; if ($val-&gt;cate_pid != 0)&#123; $val['cate_name'] = str_repeat('&amp;nbsp;&amp;nbsp;&amp;nbsp;',$space).'▲ '.$val['cate_name']; &#125; $result[] = $val; $this-&gt;getTree($val-&gt;cate_id,$result,$space); &#125; return $result; &#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云图床API接口指南]]></title>
    <url>%2F2018%2F02%2F02%2F%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8AAPI%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[登录到七牛云官网注册一个账号地址：http://www.qiniu.com 获取对应的七牛云秘钥位置：个人面板-&gt;秘钥管理获取一对 AccessKey/SecretKey 秘钥 建立存储空间位置：对象存储对象存储中可以管理上传的文件、对空间的设置、域名绑定、样式分割符设置及图片样式设定。 基本用法文档地址：http://developer.qiniu.com/code/v7/sdk/php.html#usage 1、引入SDK无论你是通过哪种方式安装的 SDK，只需要一句简单的 require 语句将安装好的SDK包含到你的项目中。请参考如下表格，找到适合你的安装方式，将SDK引入到你的项目中。请用你项目中的实际路径替换 path_to_sdk。 1234567891011Composer 安装require 'path_to_sdk/vendor/autoload.php';下载Composer安装包require 'path_to_sdk/vendor/autoload.php';下载源码安装包require 'path_to_sdk/autoload.php'; 2、SDK结构 可以直接查看我们的SDK目录，即可大致了解我们SDK的结构。 最外层包含：配置文件， 鉴权和一些公共的函数 HTTP 目录主要包含了一些对 http 进行封装的类，这块你可以不用关心。 Storage 目录主要包含两大块：Bucket 中文件的管理和文件的上传。 Processing 目录主要包含文件的处理，文件处理又包含两个方面：同步处理和异步处理。 为了帮助您更好的了解和使用我们的sdk，我们还提供了各种使用示例。 如果使用中遇到问题，可以通过Github或者我们的工单进行反馈。下面我们对一些关键点进行简单的介绍，方便您快速入门。 3、鉴权类在使用七牛的SDK的过程中鉴权是很重要的一块，不管是上传鉴权，下载签权， 还是回调的签权。 PHP SDK 中的Auth类封装了所有的鉴权方式。 所以在使用 PHP SDK 时基本都会先对鉴权类进行初始化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php require 'path_to_sdk/vendor/autoload.php'; use Qiniu\Auth; // 用于签名的公钥和私钥 $accessKey = 'Access_Key'; $secretKey = 'Secret_Key'; // 初始化签权对象 $auth = new Auth($accessKey, $secretKey);```` 初始化好Auth 类后，就可以调用相应的方法了，比如生成私有下载链接方法 privateDownloadUrl，获取上传Token方法 uploadToken，验证回调方法 verifyCallback等。### 上传流程````php&lt;?php require_once 'path_to_sdk/vendor/autoload.php'; //引入类库文件 建议用composer方式 // 引入鉴权类 use Qiniu\Auth; //命名空间 // 引入上传类 use Qiniu\Storage\UploadManager; //命名空间 // 需要填写你的 Access Key 和 Secret Key //这里就用到了注册账户后用到的两个秘钥 $accessKey = 'Access_Key'; $secretKey = 'Secret_Key'; // 构建鉴权对象 $auth = new Auth($accessKey, $secretKey); // 要上传的空间 $bucket = 'Bucket_Name'; //设定的上传空间名 // 生成上传 Token $token = $auth-&gt;uploadToken($bucket); // 要上传文件的本地路径 $filePath = './php-logo.png'; //上传时候图片在本地的路径 // 上传到七牛后保存的文件名 $key = 'my-php-logo.png'; //保存到七牛上面的命名 // 初始化 UploadManager 对象并进行文件的上传 $uploadMgr = new UploadManager(); // 调用 UploadManager 的 putFile 方法进行文件的上传 list($ret, $err) = $uploadMgr-&gt;putFile($token, $key, $filePath); echo "\n====&gt; putFile result: \n"; if ($err !== null) &#123; var_dump($err); //返回结果根据需要处理 &#125; else &#123; var_dump($ret); &#125; 文件下载1234567891011121314151617&lt;?php require 'path_to_sdk/vendor/autoload.php'; // 引入鉴权类 use Qiniu\Auth; // 需要填写你的 Access Key 和 Secret Key $accessKey = 'Access_Key'; $secretKey = 'Secret_Key'; // 构建鉴权对象 $auth = new Auth($accessKey, $secretKey); //baseUrl构造成私有空间的域名/key的形式 $baseUrl = 'http://domain/key'; //空间名+文件名 的格式 $authUrl = $auth-&gt;privateDownloadUrl($baseUrl); //加密处理后再返回 echo $authUrl;?&gt; 删除单个文件123456789101112131415161718192021222324252627&lt;?php require_once 'path_to_sdk/vendor/autoload.php'; use Qiniu\Auth; use Qiniu\Storage\BucketManager; $accessKey = 'Access_Key'; $secretKey = 'Secret_Key'; //初始化Auth状态 $auth = new Auth($accessKey, $secretKey); //初始化BucketManager $bucketMgr = new BucketManager($auth); //你要测试的空间， 并且这个key在你空间中存在 $bucket = 'Bucket_Name'; $key = 'php-logo.png'; //删除$bucket 中的文件 $key $err = $bucketMgr-&gt;delete($bucket, $key); //空间名 和 未加密的文件名 echo "\n====&gt; delete $key : \n"; if ($err !== null) &#123; var_dump($err); &#125; else &#123; echo "Success!"; &#125; 还有更多的操作请参考官方文档，地址：http://developer.qiniu.com/code/v7/sdk/php.html#install 实际案例（实战项目中的方法封装） 12345/七牛云图片上传配置const ACCESS_KEY = 'byJc-8owLt9G5ljXsNYbTsfOCKzQgTV4UTPu3sCG' ; //私钥AKconst SECRET_KEY = '6ybTxRxyDGndimpVMgK_k-6s1prGIPkGtB0Xolyb' ; //私钥SKconst QINIU_BUCKET = 'op-zbj' ; //空间名（对象存储中）const BASE_URL = 'http://ohsllkayi.bkt.clouddn.com' ; //外链默认域名（对象存储-&gt;内容管理） 1234567891011121314151617181920212223242526272829/*** 上传图片到七牛云* @param $filePath 图片的本地路径* @param $fileName 图片名* @return mixed array* @throws Exception*/public function UploadPicToQiNiu ($fileName , $filePath)&#123; // 初始化签权对象 $auth = new Auth(lib_Constant:: ACCESS_KEY , lib_Constant:: SECRET_KEY ); // 生成上传 Token $token = $auth-&gt; uploadToken (lib_Constant:: QINIU_BUCKET) ; // 上传到七牛后保存的文件名 $key = 'qiniu_'.md5( $fileName .rand(100 , 999)) ; // 初始化 UploadManager 对象并进行文件的上传 $uploadMgr = new UploadManager() ; // 调用 UploadManager 的 putFile 方法进行文件的上传 list ( $ret, $err ) = $uploadMgr -&gt; putFile( $token , $key , $filePath) ; if ($err !== null) &#123; return $err ; &#125; else &#123; return $ret ; &#125;&#125; 1234567891011121314/*** 从七牛云上获取图片到本地* @param $filePath 数据库中的图片地址* @return string*/public function downloadPicToQiNiu ($filePath )&#123; // 构建鉴权对象 $auth = new Auth(lib_Constant:: ACCESS_KEY , lib_Constant:: SECRET_KEY ); //baseUrl构造成私有空间的域名/key的形式 $baseUrl = lib_Constant:: BASE_URL. '/' .$filePath ; $authUrl = $auth-&gt; privateDownloadUrl ($baseUrl ) ; return $authUrl;&#125; 1234567891011121314151617181920/*** 批量获取七牛云上的图片* @param $filePathArray* @return array|bool*/public function batchDownloadPicToQiNiu ( $filePathArray)&#123; if ( empty( $filePathArray ))&#123; return false; &#125; // 构建鉴权对象 $returnFullImagesPath = [] ; $auth = new Auth(lib_Constant:: ACCESS_KEY , lib_Constant:: SECRET_KEY ); foreach ($filePathArray as $filePath)&#123; //baseUrl构造成私有空间的域名/key的形式 $baseUrl = lib_Constant:: BASE_URL. '/' .$filePath ; $returnFullImagesPath [] = $auth -&gt;privateDownloadUrl ( $baseUrl) ; &#125; return $returnFullImagesPath ;&#125; 123456789101112131415161718192021/*** 从七牛云上删除图片* @param $filePath* @return mixed*/public function deleteToQiNiu ($filePath )&#123; //初始化Auth状态 $auth = new Auth(lib_Constant:: ACCESS_KEY , lib_Constant:: SECRET_KEY ); //初始化BucketManager $bucketMgr = new BucketManager( $auth ); //删除$bucket 中的文件 $key $err = $bucketMgr -&gt; delete(lib_Constant:: QINIU_BUCKET ,$filePath ) ; // echo "\n====&gt; delete $key : \n"; if ( $err !== null ) &#123; return fasle ; &#125; else &#123; return true; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中静态方法(static)与非静态方法的使用及区别]]></title>
    <url>%2F2018%2F02%2F02%2FPHP%E4%B8%AD%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-static-%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[表述 static方法是类中的一个成员方法,属于整个类,即使不用创建任何对象也可以直接调用! 静态方法效率上要比实例化高，静态方法的缺点是不自动进行销毁，而实例化的则可以做销毁 静态方法和静态变量创建后始终使用同一块内存，而使用实例的方式会创建多个内存。 C++中，若类的方法前加了static关键字，则该方法称为静态方法，反之为实例方法。静态方法为类所有，可以通过对象来使用，也可以通过类来使用。但一般提倡通过类名来使用，因为静态方法只要定义了类，不必建立类的实例就可使用。静态方法只能用类的静态成员 static关键字用来修饰属性、方法，称这些属性、方法为静态属性、静态方法。 static关键字声明一个属性或方法是和类相关的，而不是和类的某个特定的实例相关，因此，这类属性或方法也称为“类属性”或“类方法” 如果访问控制权限允许，可不必创建该类对象而直接使用类名加两个冒号“::”调用。 static关键字可以用来修饰变量、方法。 不经过实例化，就可以直接访问类中static的属性和static的方法。 static 的属性和方法，只能访问static的属性和方法，不能类访问非静态的属性和方法。因为静态属性和方法被创建时，可能还没有任何这个类的实例可以被调用. static的属性，在内存中只有一份，为所有的实例共用 使用self:: 关键字访问当前类的静态成员. 一个类的所有实例，共用类中的静态属性 实现下面例子中的设置了一个计数器$count属性，设置private 和 static 修饰。这样，外界并不能直接访问$count属性。而程序运行的结果我们也看到多个实例在使用同一个静态的$count 属性12345678910111213141516171819202122&lt;?PHP class user &#123; private static $count = 0 ; //记录所有用户的登录情况. public function __construct() &#123; self::$count = self::$count + 1; &#125; public function getCount() &#123; return self::$count; &#125; public function __destruct() &#123; self::$count = self::$count - 1; &#125; &#125; $user1 = new user(); $user2 = new user(); $user3 = new user(); echo "now here have " . $user1-&gt;getCount() . " user"; echo "&lt;br /&gt;"; unset($user3); echo "now here have " . $user1-&gt;getCount() . " user"; ?&gt; 静态属性直接调用,静态属性不需要实例化就可以直接使用，在类还没有创建时就可以直接使用 使用的方式是： 类名::静态属性名123456789101112131415&lt;?php class Math &#123; public static $pi = 3.14; &#125; // 求一个半径3的园的面积。 $r = 3; echo "半径是 $r 的面积是&lt;br /&gt;"; echo Math::$pi * $r * $r; echo "&lt;br /&gt;&lt;br /&gt;"; //这里我觉得 3.14 不够精确，我把它设置的更精确。 Math::$pi = 3.141592653589793; echo "半径是 $r 的面积是&lt;br /&gt;"; echo Math::$pi * $r * $r; ?&gt; 类没有创建，静态属性就可以直接使用。那静态属性在什么时候在内存中被创建？ 在PHP中没有看到相关的资料。引用Java中的概念，来解释应该也具有通用性 静态方法静态方法不需要所在类被实例化就可以直接使用。 使用的方式是类名：：静态方法名 下面我们继续写这个Math类，用来进行数学计算。我们设计一个方法用来算出其中的最大值。既然是数学运算，我们也没有必要去实例化这个类，如果这个方法 可以拿过来就用就方便多了。我们这只是为了演示static方法而设计的这个类。在PHP提供了 max() 函数比较数值。123456789101112131415161718192021&lt;?php class Math &#123; public static function Max($num1, $num2) &#123; return $num1 &gt; $num2 ? $num1 : $num2; &#125; &#125; $a = 99; $b = 88; echo "显示 $a 和 $b 中的最大值是"; echo "&lt;br /&gt;"; echo Math::Max($a, $b); echo "&lt;br /&gt;"; echo "&lt;br /&gt;"; echo "&lt;br /&gt;"; $a = 99; $b = 100; echo "显示 $a 和 $b 中的最大值是"; echo "&lt;br /&gt;"; echo Math::Max($a,$b); ?&gt; 静态方法如何调用静态方法第一个例子，一个静态方法调用其它静态方法时，使用self::123456789101112131415161718192021&lt;?php // 实现最大值比较的Math类。 class Math &#123; public static function Max($num1, $num2) &#123; return $num1 &gt; $num2 ? $num1 : $num2; &#125; public static function Max3($num1, $num2, $num3) &#123; $num1 = self::Max($num1, $num2); $num2 = self::Max($num2, $num3); $num1 = self::Max($num1, $num2); return $num1; &#125; &#125; $a = 99; $b = 77; $c = 88; echo "显示 $a $b $c 中的最大值是"; echo "&lt;br /&gt;"; echo Math::Max3($a, $b, $c); ?&gt; 静态方法调用静态属性使用self:: 调用本类的静态属性。123456789101112&lt;?php // class Circle &#123; public static $pi = 3.14; public static function circleAcreage($r) &#123; return $r * $r * self::$pi; &#125; &#125; $r = 3; echo " 半径 $r 的圆的面积是 " . Circle::circleAcreage($r); ?&gt; 静态方法不能调用非静态属性 。不能使用self::调用非静态属性。 123456789101112&lt;?php // 这个方式是错误的 class Circle &#123; public $pi = 3.14; public static function circleAcreage($r) &#123; return $r * $r * self::pi; &#125; &#125; $r = 3; echo " 半径 $r 的圆的面积是 " . Circle::circleAcreage($r); ?&gt; 也不能使用 $this 获取非静态属性的值。 静态方法调用非静态方法PHP5中，在静态方法中不能使用 $this 标识调用非静态方法.12345678910111213141516171819202122&lt;?php // 实现最大值比较的Math类。 class Math &#123; public function Max($num1, $num2) &#123; echo "bad&lt;br /&gt;"; return $num1 &gt; $num2 ? $num1 : $num2; &#125; public static function Max3($num1, $num2, $num3) &#123; $num1 = $this-&gt;Max($num1, $num2); $num2 = $this-&gt;Max($num2, $num3); $num1 = $this-&gt;Max($num1, $num2); return $num1; &#125; &#125; $a = 99; $b = 77; $c = 188; echo "显示 $a $b $c 中的最大值是"; echo "&lt;br /&gt;"; echo Math::Max3($a, $b, $c); //同样的这个会报错 ?&gt; 当一个类中有非静态方法被self:: 调用时，系统会自动将这个方法转换为静态方法。123456789101112131415161718192021&lt;?php // 实现最大值比较的Math类。 class Math &#123; public function Max($num1, $num2) &#123; return $num1 &gt; $num2 ? $num1 : $num2; &#125; public static function Max3($num1, $num2, $num3) &#123; $num1 = self::Max($num1, $num2); $num2 = self::Max($num2, $num3); $num1 = self::Max($num1, $num2); return $num1; &#125; &#125; $a = 99; $b = 77; $c = 188; echo "显示 $a $b $c 中的最大值是"; echo "&lt;br /&gt;"; echo Math::Max3($a, $b, $c); ?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP给源代码加密的几种方法]]></title>
    <url>%2F2018%2F02%2F02%2FPHP%E7%BB%99%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[虽说分享是传统的美德，但我们有时候辛辛苦苦写一些程序只是为了卖点小钱，挣点辛苦费，也防止有些没有道德的人倒卖，所以我们不得不对我们的程序进行加密，以下我们来介绍一下如何通过PHP的自定义函数来加密我们的PHP源代码. 方法一：123456789101112131415161718192021222324&lt;?php function encode_file_contents($filename) &#123; $type=strtolower(substr(strrchr($filename,'.'),1)); if ('php' == $type &amp;&amp; is_file($filename) &amp;&amp; is_writable($filename)) &#123; // 如果是PHP文件 并且可写 则进行压缩编码 $contents = file_get_contents($filename); // 判断文件是否已经被编码处理 $contents = php_strip_whitespace($filename); // 去除PHP头部和尾部标识 $headerPos = strpos($contents,'&lt;?php'); $footerPos = strrpos($contents,'?&gt;'); $contents = substr($contents, $headerPos + 5, $footerPos - $headerPos); $encode = base64_encode(gzdeflate($contents)); // 开始编码 $encode = '&lt;?php'."\n eval(gzinflate(base64_decode("."'".$encode."'".")));\n\n?&gt;"; return file_put_contents($filename, $encode); &#125; return false; &#125; //调用函数 $filename = 'dam.php'; encode_file_contents($filename); echo "OK,加密完成！" ?&gt; 方法二：1234567891011121314151617181920212223242526272829&lt;?php function RandAbc($length = "") &#123; // 返回随机字符串 $str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; return str_shuffle($str); &#125; $filename = 'index.php'; //要加密的文件 $T_k1 = RandAbc(); //随机密匙1 $T_k2 = RandAbc(); //随机密匙2 $vstr = file_get_contents($filename); $v1 = base64_encode($vstr); $c = strtr($v1, $T_k1, $T_k2); //根据密匙替换对应字符。 $c = $T_k1.$T_k2.$c; $q1 = "O00O0O"; $q2 = "O0O000"; $q3 = "O0OO00"; $q4 = "OO0O00"; $q5 = "OO0000"; $q6 = "O00OO0"; $s = '$'.$q6.'=urldecode("%6E1%7A%62%2F%6D%615%5C%76%740%6928%2D%70%78%75%71%79%2A6%6C%72%6B%64%679%5F%65%68%63%73%77%6F4%2B%6637%6A");$'.$q1.'=$'.$q6.'&#123;3&#125;.$'.$q6.'&#123;6&#125;.$'.$q6.'&#123;33&#125;.$'.$q6.'&#123;30&#125;;$'.$q3.'=$'.$q6.'&#123;33&#125;.$'.$q6.'&#123;10&#125;.$'.$q6.'&#123;24&#125;.$'.$q6.'&#123;10&#125;.$'.$q6.'&#123;24&#125;;$'.$q4.'=$'.$q3.'&#123;0&#125;.$'.$q6.'&#123;18&#125;.$'.$q6.'&#123;3&#125;.$'.$q3.'&#123;0&#125;.$'.$q3.'&#123;1&#125;.$'.$q6.'&#123;24&#125;;$'.$q5.'=$'.$q6.'&#123;7&#125;.$'.$q6.'&#123;13&#125;;$'.$q1.'.=$'.$q6.'&#123;22&#125;.$'.$q6.'&#123;36&#125;.$'.$q6.'&#123;29&#125;.$'.$q6.'&#123;26&#125;.$'.$q6.'&#123;30&#125;.$'.$q6.'&#123;32&#125;.$'.$q6.'&#123;35&#125;.$'.$q6.'&#123;26&#125;.$'.$q6.'&#123;30&#125;;eval($'.$q1.'("'.base64_encode('$'.$q2.'="'.$c.'";eval(\'?&gt;\'.$'.$q1.'($'.$q3.'($'.$q4.'($'.$q2.',$'.$q5.'*2),$'.$q4.'($'.$q2.',$'.$q5.',$'.$q5.'),$'.$q4.'($'.$q2.',0,$'.$q5.'))));').'"));'; $s = '&lt;?php '."\n".$s."\n".' ?&gt;'; //echo $s; // 生成 加密后的PHP文件 $fpp1 = fopen('temp_'.$filename, 'w'); fwrite($fpp1, $s) or die('写文件错误'); ?&gt; 方法三：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283&lt;?php class text_auth &#123; var $n_iter; function text_auth() &#123; $this-&gt;setIter(32); &#125; function setIter($n_iter) &#123; $this-&gt;n_iter = $n_iter; &#125; function getIter() &#123; return $this-&gt;n_iter; &#125; function encrypt($data, $key) &#123; $n = $this-&gt;_resize($data, 4); $data_long[0] = $n; $n_data_long = $this-&gt;_str2long(1, $data, $data_long); $n = count($data_long); if (($n &amp; 1) == 1) &#123; $data_long[$n] = chr(0); $n_data_long++; &#125; $this-&gt;_resize($key, 16, true); if ( '' == $key ) $key = '0000000000000000'; $n_key_long = $this-&gt;_str2long(0, $key, $key_long); $enc_data = ''; $w = array(0, 0); $j = 0; $k = array(0, 0, 0, 0); for ($i = 0; $i &lt; $n_data_long; ++$i) &#123; if ($j + 4 &lt;= $n_key_long) &#123; $k[0] = $key_long[$j]; $k[1] = $key_long[$j + 1]; $k[2] = $key_long[$j + 2]; $k[3] = $key_long[$j + 3]; &#125; else &#123; $k[0] = $key_long[$j % $n_key_long]; $k[1] = $key_long[($j + 1) % $n_key_long]; $k[2] = $key_long[($j + 2) % $n_key_long]; $k[3] = $key_long[($j + 3) % $n_key_long]; &#125; $j = ($j + 4) % $n_key_long; $this-&gt;_encipherLong($data_long[$i], $data_long[++$i], $w, $k); $enc_data .= $this-&gt;_long2str($w[0]); $enc_data .= $this-&gt;_long2str($w[1]); &#125; return $enc_data; &#125; function decrypt($enc_data, $key) &#123; $n_enc_data_long = $this-&gt;_str2long(0, $enc_data, $enc_data_long); $this-&gt;_resize($key, 16, true); if ( '' == $key ) $key = '0000000000000000'; $n_key_long = $this-&gt;_str2long(0, $key, $key_long); $data = ''; $w = array(0, 0); $j = 0; $len = 0; $k = array(0, 0, 0, 0); $pos = 0; for ($i = 0; $i &lt; $n_enc_data_long; $i += 2) &#123; if ($j + 4 &lt;= $n_key_long) &#123; $k[0] = $key_long[$j]; $k[1] = $key_long[$j + 1]; $k[2] = $key_long[$j + 2]; $k[3] = $key_long[$j + 3]; &#125; else &#123; $k[0] = $key_long[$j % $n_key_long]; $k[1] = $key_long[($j + 1) % $n_key_long]; $k[2] = $key_long[($j + 2) % $n_key_long]; $k[3] = $key_long[($j + 3) % $n_key_long]; &#125; $j = ($j + 4) % $n_key_long; $this-&gt;_decipherLong($enc_data_long[$i], $enc_data_long[$i + 1], $w, $k); if (0 == $i) &#123; $len = $w[0]; if (4 &lt;= $len) &#123; $data .= $this-&gt;_long2str($w[1]); &#125; else &#123; $data .= substr($this-&gt;_long2str($w[1]), 0, $len % 4); &#125; &#125; else &#123; $pos = ($i - 1) * 4; if ($pos + 4 &lt;= $len) &#123; $data .= $this-&gt;_long2str($w[0]); if ($pos + 8 &lt;= $len) &#123; $data .= $this-&gt;_long2str($w[1]); &#125; elseif ($pos + 4 &lt; $len) &#123; $data .= substr($this-&gt;_long2str($w[1]), 0, $len % 4); &#125; &#125; else &#123; $data .= substr($this-&gt;_long2str($w[0]), 0, $len % 4); &#125; &#125; &#125; return $data; &#125; function _encipherLong($y, $z, &amp;$w, &amp;$k) &#123; $sum = (integer) 0; $delta = 0x9E3779B9; $n = (integer) $this-&gt;n_iter; while ($n-- &gt; 0) &#123; $y = $this-&gt;_add($y, $this-&gt;_add($z &lt;&lt; 4 ^ $this-&gt;_rshift($z, 5), $z) ^ $this-&gt;_add($sum, $k[$sum &amp; 3])); $sum = $this-&gt;_add($sum, $delta); $z = $this-&gt;_add($z, $this-&gt;_add($y &lt;&lt; 4 ^ $this-&gt;_rshift($y, 5), $y) ^ $this-&gt;_add($sum, $k[$this-&gt;_rshift($sum, 11) &amp; 3])); &#125; $w[0] = $y; $w[1] = $z; &#125; function _decipherLong($y, $z, &amp;$w, &amp;$k) &#123; $sum = 0xC6EF3720; $delta = 0x9E3779B9; $n = (integer) $this-&gt;n_iter; while ($n-- &gt; 0) &#123; $z = $this-&gt;_add($z, -($this-&gt;_add($y &lt;&lt; 4 ^ $this-&gt;_rshift($y, 5), $y) ^ $this-&gt;_add($sum, $k[$this-&gt;_rshift($sum, 11) &amp; 3]))); $sum = $this-&gt;_add($sum, -$delta); $y = $this-&gt;_add($y, -($this-&gt;_add($z &lt;&lt; 4 ^ $this-&gt;_rshift($z, 5), $z) ^ $this-&gt;_add($sum, $k[$sum &amp; 3]))); &#125; $w[0] = $y; $w[1] = $z; &#125; function _resize(&amp;$data, $size, $nonull = false) &#123; $n = strlen($data); $nmod = $n % $size; if ( 0 == $nmod ) $nmod = $size; if ($nmod &gt; 0) &#123; if ($nonull) &#123; for ($i = $n; $i &lt; $n - $nmod + $size; ++$i) &#123; $data[$i] = $data[$i % $n]; &#125; &#125; else &#123; for ($i = $n; $i &lt; $n - $nmod + $size; ++$i) &#123; $data[$i] = chr(0); &#125; &#125; &#125; return $n; &#125; function _hex2bin($str) &#123; $len = strlen($str); return pack('H' . $len, $str); &#125; function _str2long($start, &amp;$data, &amp;$data_long) &#123; $n = strlen($data); $tmp = unpack('N*', $data); $j = $start; foreach ($tmp as $value) $data_long[$j++] = $value; return $j; &#125; function _long2str($l) &#123; return pack('N', $l); &#125; function _rshift($integer, $n) &#123; if (0xffffffff &lt; $integer || -0xffffffff &gt; $integer) &#123; $integer = fmod($integer, 0xffffffff + 1); &#125; if (0x7fffffff &lt; $integer) &#123; $integer -= 0xffffffff + 1.0; &#125; elseif (-0x80000000 &gt; $integer) &#123; $integer += 0xffffffff + 1.0; &#125; if (0 &gt; $integer) &#123; $integer &amp;= 0x7fffffff; $integer &gt;&gt;= $n; $integer |= 1 &lt;&lt; (31 - $n); &#125; else &#123; $integer &gt;&gt;= $n; &#125; return $integer; &#125; function _add($i1, $i2) &#123; $result = 0.0; foreach (func_get_args() as $value) &#123; if (0.0 &gt; $value) &#123; $value -= 1.0 + 0xffffffff; &#125; $result += $value; &#125; if (0xffffffff &lt; $result || -0xffffffff &gt; $result) &#123; $result = fmod($result, 0xffffffff + 1); &#125; if (0x7fffffff &lt; $result) &#123; $result -= 0xffffffff + 1.0; &#125; elseif (-0x80000000 &gt; $result) &#123; $result += 0xffffffff + 1.0; &#125; return $result; &#125; &#125; ?&gt; 使用方法参考如下：// 加密过程view sourceprint? $text_file = S_ROOT . './456.php'; $str = @file_get_contents($text_file); require_once S_ROOT . "./text_auth.php"; $text_auth = new text_auth(64); $str = $text_auth-&gt;encrypt($str, "qianyunlai.com"); $filename = S_ROOT . './789.php'; // 加密后的文本为二进制，普通的文本编辑器无法正常查看 file_put_contents($filename, $str); // 解密过程view sourceprint?01 $text_file = S_ROOT . './789.php'; $str = @file_get_contents($text_file); require_once S_ROOT . "./text_auth.php"; $text_auth = new text_auth(64); $str = $text_auth-&gt;decrypt($str, "qianyunlai.com"); $filename = S_ROOT . './456.php'; file_put_contents($filename, $str); 该方法可以对文本的内容进行 二进制加密 与 解密。 以上几种方法各有各的优点和用处，大家也选择使用]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker的基本操作]]></title>
    <url>%2F2018%2F01%2F31%2FDocker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[今天是公司2018年的年会，地点定在渝中区大礼堂，下午1点30开始，上午几乎所有的小伙伴都按捺不住自己内心澎湃的心一心准备参加公司的年会，不知道是不是做程序员做久了，还是说早已习惯了公司的”套路”，不觉得年会有什么新鲜感和吸引我的地方，当然说句实话，年会对我吸引最大的肯定是抽奖环节，据说今年的终极大奖是现金10万；趁着这么还有点时间，更新下自己的博客吧使用Docker还是蛮久的了，但对于我来时，基本都是针对于开发搭建环境使用，所以也就只会一些基本的使用，要想看深入讲解的，请绕道咯。 Docker简介DockerDocker是一个开源平台，用于自动化部署应用，以通过快捷的途径在称之为容器的轻量级软件层下打包、发布和运行这些应用。它使得应用平台独立，因为它扮演了Linux上一个额外的操作系统级虚拟化的自动化抽象层。它通过其组件cgroups和命名空间利用Linux内核的资源分离特性，达到避免虚拟机开销的目的。它使得用于部署和扩展web应用、数据库和后端服务的大规模构建组件无需依赖于特定的堆栈或供应者。 容器所谓的容器，就是那些创建自Docker镜像的软件层，它包含了独立的Linux文件系统和开箱即用的应用程序。如果我们有一个在机器中运行着的Docker容器，并且想要备份这些容器以便今后使用，或者想要迁移这些容器，那么，本教程将帮助你掌握在Linux操作系统中备份、恢复和迁移Docker容器的方法 使用及介绍操作命令显示docker系统信息1docker info 镜像搜索1docker search php 获取镜像1docker pull richarvey/nginx-php-fpm (需要哪个就pull哪个) 导入本地镜像1docker load &gt; ~/Users/xiexiang/Downloads/[镜像名] 查看镜像1docker images 显示镜像的历史1docker history 删除镜像1docker rmi -f richarvey/nginx-php-fpm (带f据说不会残留垃圾) 创建容器1docker run -d -p 80:80 --name php-zzgg-un -v /Users/xiexiang/myproject/bajieke:/var/www/html registry.alauda.cn/neucloud/nginx-php-fpm:latest 查看容器(全部)1docker ps -a 查看已运行容器1docker ps 删除容器1docker rm -f [容器id] 进入到容器1docker exec -it [容器名] bash 启动容器1docker start [容器名] 停止容器1docker stop [容器名] 重启容器1docker restart [容器名] 容器的导出导入功能1、停止容器(也可以不停止，只要下一步commit成功即可)1docker stop [容器名] 2、将容器commit为镜像 12345docker commit ec1f968cc0d0 php-zzgg-un (容器id 自定义镜像名)```` 查看生成的镜像````phpdocker images 3、save镜像为tar文件 1docker save -o /Users/xiexiang/Downloads/php-zzgg-un.tar php-zzgg-un 4、将tar文件scp到 目标docker主机 1scp php-zzgg-un.tar root@10.45.7.197:/docker 5、导入本地镜像 docker load /Users/xiexiang/Downloads/php-zzgg-un.tar]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建的博客如何给文章分类（NEXT主题）]]></title>
    <url>%2F2018%2F01%2F25%2Fhexo%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E7%BB%99%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB%EF%BC%88NEXT%E4%B8%BB%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[tags：12345tags: - 前端- hexocategories: - 前端 在博客根目录输入1hexo new page tags 打开 tags/index.md ，并改成：1234title: 标签date: 日期type: "tags"comments: false 分类（同理）1hexo new page categories 打开category/index.md，改为：1234title: 分类date: 日期type: "categories"comments: false]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程即时修改微信菜单]]></title>
    <url>%2F2018%2F01%2F24%2F%E8%BF%9C%E7%A8%8B%E5%8F%8A%E6%97%B6%E4%BF%AE%E6%94%B9%E5%BE%AE%E4%BF%A1%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[场景： 某天程序员A加班加点完成了本次微信项目的迭代工作，在使用全身解数之后终于盼来了上线的等待，当然，后面也是成功上线了，但是项目经理在看过线上项目之后，才发现程序员A在微信后台修改的操作菜单并没有生效，当然程序员A也知道，这个生效要等一小时左右，但是项目经理急了，’我马上要给客户看，怎么能等待生效’。 这是一个线上执行的单文件，如有需要拆分成各个板块形成方法，可以自行去改。直接执行以下代码能即时修改微信菜单，比微信后台修改操作快很多。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118$appid = "xxxxxxx"; //微信appid$appsecret = "xxxxxxxxxxx"; //微信secret_id$url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$appid&amp;secret=$appsecret";$host = "http://xxxxxx.com"; //站点域名$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$output = curl_exec($ch);curl_close($ch);$jsoninfo = json_decode($output, true);$access_token = $jsoninfo["access_token"];header("Content-type: text/html; charset=utf-8");//创建菜单function createMenu($data, $access_token)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, "https://api.weixin.qq.com/cgi-bin/menu/create?access_token=".$access_token); curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST"); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (compatible; MSIE 5.01; Windows NT 5.0)'); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_AUTOREFERER, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $tmpInfo = curl_exec($ch); if (curl_errno($ch)) &#123; return curl_error($ch); &#125; curl_close($ch); return $tmpInfo;&#125; //获取菜单 function getMenu()&#123; return file_get_contents("https://api.weixin.qq.com/cgi-bin/menu/get?access_token=".ACCESS_TOKEN); &#125;//删除菜单 function deleteMenu()&#123; return file_get_contents("https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=".ACCESS_TOKEN); &#125; $data = array( "button" =&gt; array( array( "name"=&gt;urlencode("推广赚钱"), "sub_button"=&gt;array( array( "type"=&gt;"view", "name"=&gt;urlencode("首页"), "url"=&gt;$host."/default/index?needLogin=1&amp;agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("做任务"), "url"=&gt;$host."/proxy/taskHall?agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("提商机"), "url"=&gt;$host."/business/add?agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("推广爆品"), "url"=&gt;$host."/proxy/home?agent_r=agent_wx" ),array( "type"=&gt;"view", "name"=&gt;urlencode("推广店铺"), "url"=&gt;$host."/rebateshop/index?agent_r=agent_wx" ) ) ), array( "name"=&gt;urlencode("发展下级"), "sub_button"=&gt;array( array( "type"=&gt;"view", "name"=&gt;urlencode("发展下级"), "url"=&gt;$host."/invite/newinviteentershow?agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("管理下级"), "url"=&gt;$host."/partner/mypartner?agent_r=agent_wx" ) ) ), array( "name"=&gt;urlencode("我的"), "sub_button"=&gt;array( array( "type"=&gt;"view", "name"=&gt;urlencode("收益"), "url"=&gt;$host."/earnings/BalanceCommission?agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("我的店铺"), "url"=&gt;$host."/shop/detail?agent_r=agent_wx" ), array( "type"=&gt;"view", "name"=&gt;urlencode("个人中心"), "url"=&gt;$host."/home/ucenter?agent_r=agent_wx" ) ) ) ) ); //转义汉字 $data = json_encode($data); $data = urldecode($data);echo $data;echo "&lt;br&gt;\n";echo createMenu($data, $access_token);echo "\n";]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的 抽象类（abstract class）和 接口（interface）]]></title>
    <url>%2F2017%2F12%2F15%2FPHP%E4%B8%AD%E7%9A%84%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract%20class%EF%BC%89%E5%92%8C%20%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89%2F</url>
    <content type="text"><![CDATA[抽象类abstract class 抽象类是指在class前加了abstract关键字且存在抽象方法（在类方法function关键字前加了abstract关键字）的类。 抽象类不能被直接实例化。抽象类中只定义（或部分实现）子类需要的方法。子类可以通过继承抽象类并通过实现抽象类中的所有抽象方法，使抽象类具体化。 如果子类需要实例化，前提是它实现了抽象类中的所有抽象方法。如果子类没有全部实现抽象类中的所有抽象方法，那么该子类也是一个抽象类，必须在class前面加上abstract关键字，并且不能被实例化。 12345678910111213141516171819202122232425262728293031323334abstract class A &#123; /** 抽象类中可以定义变量 */ protected $value1 = 0; private $value2 = 1; public $value3 = 2; /** 也可以定义非抽象方法 */ public function my_print() &#123; echo "hello,world/n"; &#125; /** * 大多数情况下，抽象类至少含有一个抽象方法。抽象方法用abstract关键字声明，其中不能有具体内容。 * 可以像声明普通类方法那样声明抽象方法，但是要以分号而不是方法体结束。也就是说抽象方法在抽象类中不能被实现，也就是没有函数体“&#123;some codes&#125;”。 */ abstract protected function abstract_func1(); abstract protected function abstract_func2(); &#125; abstract class B extends A &#123; public function abstract_func1() &#123; echo "implement the abstract_func1 in class A/n"; &#125; /** 这么写在zend studio 8中会报错*/ //abstract protected function abstract_func2(); &#125; class C extends B &#123; public function abstract_func2() &#123; echo "implement the abstract_func2 in class A/n"; &#125; &#125; 如果像下面这样创建了一个继承自A的子类B，但是不实现抽象方法abstract_func()： 12345Class B extends A&#123;&#125;; ``` 那么程序将出现以下错误：```phpFatal error: Class B contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (A::abstract_func) 如果B实现了抽象方法abstract_func()，那么B中abstract_func()方法的访问控制不能比A中abstract_func()的访问控制更严格，也就是说：(1)如果A中abstract_func()声明为public，那么B中abstract_func()的声明只能是public，不能是protected或private(2)如果A中abstract_func()声明为protected，那么B中abstract_func()的声明可以是public或protected，但不能是private(3)如果A中abstract_func()声明为private，嘿嘿，不能定义为private哦！（Fatal error: Abstract function A::abstract_func() cannot be declared private） 接口interface 抽象类提供了具体实现的标准，而接口则是纯粹的模版。接口只定义功能，而不包含实现的内容。接口用关键字interface来声明。 interface是完全抽象的，只能声明方法，而且只能声明public的方法，不能声明private及protected的方法，不能定义方法体，也不能声明实例变量。然而，interface却可以声明常量变量。但将常量变量放在interface中违背了其作为接口的作用而存在的宗旨，也混淆了interface与类的不同价值。如果的确需要，可以将其放在相应的abstract class或Class中。 12345678910111213141516171819 interface iA &#123; const AVAR=3; public function iAfunc1(); public function iAfunc2(); &#125; echo iA:: AVAR; ``` * 任何实现接口的类都要实现接口中所定义的所有方法```php class E implements iA &#123; public function iAfunc1()&#123;echo "in iAfunc1";&#125; public function iAfunc2()&#123;echo "in iAfunc2";&#125; &#125; ``` 否则该类必须声明为abstract。```phpabstract class E implements iA&#123;&#125; 一个类可以在声明中使用implements关键字来实现某个接口。这么做之后，实现接口的具体过程和继承一个仅包含抽象方法的抽象类是一样的。一个类可以同时继承一个父类和实现任意多个接口。extends子句应该在implements子句之前。PHP只支持继承自一个父类，因此extends关键字后只能跟一个类名。 12345678910111213141516171819202122232425262728293031323334353637interface iB &#123; public function iBfunc1(); public function iBfunc2(); &#125; class D extends A implements iA,iB &#123; public function abstract_func1() &#123; echo "implement the abstract_func1 in class A/n"; &#125; public function abstract_func2() &#123; echo "implement the abstract_func2 in class A/n"; &#125; public function iAfunc1()&#123;echo "in iAfunc1";&#125; public function iAfunc2()&#123;echo "in iAfunc2";&#125; public function iBfunc1()&#123;echo "in iBfunc1";&#125; public function iBfunc2()&#123;echo "in iBfunc2";&#125; &#125; class D extends B implements iA,iB &#123; public function abstract_func1() &#123; parent::abstract_func1(); echo "override the abstract_func1 in class A/n"; &#125; public function abstract_func2() &#123; echo "implement the abstract_func2 in class A/n"; &#125; public function iAfunc1()&#123;echo "in iAfunc1";&#125; public function iAfunc2()&#123;echo "in iAfunc2";&#125; public function iBfunc1()&#123;echo "in iBfunc1";&#125; public function iBfunc2()&#123;echo "in iBfunc2";&#125; &#125; 接口不可以实现另一个接口，但可以继承多个 interface iC extends iA,iB{} class F implements iC { public function iAfunc1(){echo "in iAfunc1";} public function iAfunc2(){echo "in iAfunc2";} public function iBfunc1(){echo "in iBfunc1";} public function iBfunc2(){echo "in iBfunc2";} } 抽象类和接口的异同相同点： 两者都是抽象类，都不能实例化。 interface实现类及abstract class的子类都必须要实现已经声明的抽象方法。不同点： interface需要实现，要用implements，而abstract class需要继承，要用extends。 一个类可以实现多个interface，但一个类只能继承一个abstract class。 interface强调特定功能的实现，而abstract class强调所属关系。 尽管interface实现类及abstract class的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstractclass的子类可以有选择地实现。这个选择有两点含义：a) abstract class中并非所有的方法都是抽象的，只有那些冠有abstract的方法才是抽象的，子类必须实现。那些没有abstract的方法，在 abstract class中必须定义方法体；b) abstract class的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。 abstract class是interface与class的中介。abstract class在interface及class中起到了承上启下的作用。一方面，abstract class是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己的实例变量，以供子类通过继承来使用。 接口中的抽象方法前不用也不能加abstract关键字，默认隐式就是抽象方法，也不能加final关键字来防止抽象方法的继承。而抽象类中抽象方法前则必须加上abstract表示显示声明为抽象方法。 接口中的抽象方法默认是public的，也只能是public的，不能用private，protected修饰符修饰。而抽象类中的抽象方法则可以用public，protected来修饰，但不能用private。interface的应用场合 类与类之间需要特定的接口进行协调，而不在乎其如何实现。 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。abstract class的应用场合一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有： 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能 。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http中的referer]]></title>
    <url>%2F2017%2F11%2F24%2Fhttp%E4%B8%AD%E7%9A%84referer%2F</url>
    <content type="text"><![CDATA[安全培训中提到可以通过referer判断安全性，hackbar中也有一个enable referer的选项，则，这个referer到底是个什么角色？ 在http请求的Headers部分可见Referer. 1Referer http://www.baidu.com/s?tn=98835442_hao_pg&amp;ie=utf-8&amp;f=3&amp;wd=126.com&amp;oq=126.&amp;bs=126.com&amp;rsv_bp=1&amp;inputT=5799&amp;rsp=0 Http协议头中的Referer主要用来让服务器判断来源页面, 即用户是从哪个页面来的,通常被网站用来统计用户来源,是从搜索页面来的,还是从其他网站链接过来,或是从书签等访问,以便网站合理定位. Referer有时也被用作防盗链, 即下载时判断来源地址是不是在网站域名之内, 否则就不能下载或显示,很多网站,如天涯就是通过Referer页面来判断用户是否能够下载图片 当然,对于某些恶意用户,也可能伪造Referer来获得某些权限,在设计网站时要考虑到这个问题. 还可用做电子商务网站的安全，在提交信用卡等重要信息的页面用referer来判断上一页是不是自己的网站，如果不是，可能是黑客用自己写的一个表单，来提交，为了能跳过你上一页里的javascript的验证等目的。 但是注意不要把Rerferer用在身份验证或者其他非常重要的检查上，因为Rerferer非常容易在客户端被改变。 （火狐的一个插件RefControl修改Referer引用） 对浏览器来说,一般以下几种情况是不会发送Referer,因为可能有潜在的安全问题: 123456781.用户手动输入网址或是从收藏夹/书签中访问.2.页面从Https跳转到Http；应该是处于安全考虑，该点在RFC-2616中有说明；主流浏览器均遵守这个规则，比如IE、FF；但默认情况下Https到Https是会发送Referer的安全问题在于有可能把地址中含有的一些关于用户的敏感信息发送到其他恶意网站上.3、由于FF提供了很强大的自定义参数设置功能，所以我们可以通过about:config页面修改以下两个选项的默认设置：network.http.sendRefererHeader (default=2)设置Referer的发送方式，0为完全不发送，1为只在点击链接时发送，在访问页面中的图像什么的时候不发送，2为始终发送。 参考： http://blog.csdn.net/mutsinghua/article/details/5187595]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>referer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP编程]]></title>
    <url>%2F2017%2F11%2F23%2FPHP%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[PHP基本语法数组123456789101112131415161718192021222324252627282930313233343536array_chunk($array, $size): 将数组按size大小分为多个数组array_diff($a, $b): 比较数组的不同，可以用来判断两个数组是否相等，需要注意的是这里返回的是在array1中但是不在array2中的值，而不是两个的交集array_key_exists("key",$a) # 查看key是否存在于某个字典array_intersect($array1, $array2[,$array $...]) # 返回一个数组，该数组包含了所有在array1同时也出现在其他参数数组中的值array_merge() # 合并数组，相同的key直接覆盖array_merge_recursive() # 合并数组，相同的key不覆盖array_push($source, "red", "gree") # 给数组添加元素array_search(): 搜索一个key的索引，如果是二维的数组，那么就是通过value搜索keyarray_search(strtolower($search), array_map('strtolower', $array)): array_search忽略大小写array_slice($arr, 0, 1) # 数组分片array_sum($arr): 计算数组中所有值的和array_values($arr): 获取数组所有的value值 count()函数：输出数组的长度empty()函数：判断数组是否为空end() // 返回当前数组的最后一个值，需要注意的是这个函数不仅仅是返回最后一个值，还会把数组当前的指针指向最后一个数据explode(',', $str) # 将字符串分割为数组 implode(',', $arr) # 将数组拼接成字符串in_array('a', $a) # 查看数组是否存在某个元素json_encode($arr) # 数组转换城字符串list($a, $b) = [1, 2] # 分别赋值rsort(): 以降序对数组排序sort(); # 排序，可以给数组排序，会修改原来数组的值uasort($array, $cmp_function) # 定义对比函数进行排序unset(arr[1]): 删除数组元素# 数组遍历foreach($array as $value): 数组遍历foreach($array as $key =&gt; $value): 数组(字典)遍历 # 数组用于函数func(*list): 将数组作为函数的输入 # 在数组里面添加数组元素，在不确定key的情况下$arr = [];$arr['a'][] = 'a';$arr['a'][] = 'b'; 字符串PHP里面单引号和双引号确实有些地方的用法是不同的，比如匹配换行符的时候1234567891011121314151617181920212223242526272829json_decode(string, $assoc=false) # 将字符串转换为json对象,$assoc=true时返回array而不是objectlcfirst($str) # 将字符串首字母转换为小写mb_strlen($str, 'utf-8') # 求中文字符串长度mb_substr($str, $start, $length, 'utf-8'): 字符串分割，可以分割中文哟，如果要获得所有右边的，那么$length不用填或者填上NULL，如果版本不行那就是用功能弱一点的substrnl2br() # 将字符串中的\n转换成网页的换行符&lt;br&gt;sprintf() # 字符串格式化，需要注意的是，它不是用\转义，而是用的%来转义strlen() # 求字符串长度strpos('abc', 'a'); # 在字符串中查找第一次出现位置，没找到返回falsestr_repeat('abc', n) # 将字符串重复n次str_replace(搜索值，替换值，目标) # 字符串替换str_replace("\n", "", $content); # 去除换行符substr_count($haystack, $needle, [$offset, $length]); # 计算子字符串needle在字符串haystack中出现的次数trim($string); # 去除字符串前后的空白字符，如果要去除所有的字符只能使用preg_replace('/\s+/', '', $string)，这是stackoverflow上面给出的答案$a . $b . 'abc':字符串连接直接用点号explode(',', $str, [$limit]) # 字符串分割，第三个参数大于0表示限制分组数量，limit规定所返回的数组元素的个数，小于0时，返回包含除了最后的-limit个元素以外的所有元素的数组；0表示返回包含一个元素的数组array_map('strrev', explode('-', strrev($a), 2)) # 字符串分割，逆向iconv('utf-8', 'GBK', $data): 将字符编码从utf-8转换为GBKjoin("&amp;", $arr) # 拼接字符串parse_str('name=wang&amp;age=18'): 从查询字符串中解析到变量，可以得到$name和$age两个变量parse_url($url): 解析url成数组，与http_build_query()功能相反preg_replace('/user_id=\d+&amp;name=/', 'user_id=' . 1048 . '&amp;name=', $code): 正则替换preg_replace_callback('//', function($matches)&#123;return strtolower($matchs[0])&#125;: 执行一个正则表达式搜索并且使用一个回调函数进行替换preg_match('/Chongqing(?&lt;right&gt;.*)/', $string, $matches): 正则匹配，pattern参数前后必须加斜杠sprintf("sahgoiahg%s", $a): 格式化输出strtolower($str)/strtoupper($str): 大小写字符串ucfirst($str): 将字符串首字母大写ucwords($str): 将字符串每个单词首字母大写 str_replace(' ', '', lcfirst(ucwords(str_replace(['-', '_'], ' ', $str)))); # 字符串转换为驼峰命名法 数字1234567ceil()函数：向上取整rand(min, max)：产生随机数，不需要给初始值了现在intval($val): 字符串转整数，如果不是数字型字符串，那么转换会失败，失败后返回0，没错是0，mmpint ip2long(string $ip_address)：IP转换成整数值string long2ip(string $proper_address)：整数值转换成IPnumber_format(float $number) // 以千位分隔符方式格式化一个数字，返回字符串sprintf('%04d', 2) // 数字前补零 时间1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859time(): 获取当前时间戳strtotime(''): 字符串转换为时间戳gmdate("Y-m-d\TH:i:s\Z"): 获取GMT时区的时间$beginToday=mktime(0,0,0,date('m'),date('d'),date('Y')):获取今天开始时的时间戳$endToday=mktime(0,0,0,date('m'),date('d')+1,date('Y'))-1:获取今天结束时的时间戳$beginYesterday=mktime(0,0,0,date('m'),date('d')-1,date('Y'))：获取昨天开始时的时间戳$endYesterday=mktime(0,0,0,date('m'),date('d'),date('Y'))-1：获取昨天结束时的时间戳$beginLastweek=mktime(0,0,0,date('m'),date('d')-date('w')+1-7,date('Y'))：获取上周开始时的时间戳$endLastweek=mktime(23,59,59,date('m'),date('d')-date('w')+7-7,date('Y'))：获取上周结束时的时间戳$beginThismonth=mktime(0,0,0,date('m'),1,date('Y'))：获取本月开始时的时间戳$endThismonth=mktime(23,59,59,date('m'),date('t'),date('Y'))：获取本月结束时的时间戳# 单独获取当前的年、月、日、时、分、秒等date('Y-m-d H:i:s'); // 如果要单独获取或者修改格式，那么直接按照里面的格式修改即可# 输出指定格式date('Y-m-d H:i', time())# 时间的表示d: 月份中的第几天，有前导零的2位数字，01到31D: 星期中的第几天，文本表示，3个字母，Mon 到 Sunj: 月份中的第几天，没有前导零，1 到 31l:（“L”的小写字母），星期几，完整的文本格式 Sunday 到 SaturdayN: ISO-8601 格式数字表示的星期中的第几天（PHP 5.1.0 新加），1（表示星期一）到 7（表示星期天）S: 每月天数后面的英文后缀，2 个字符，st，nd，rd 或者 th。可以和 j 一起用w: 星期中的第几天，数字表示 0（表示星期天）到 6（表示星期六）z: 年份中的第几天 0 到 365星期 --- ---W ISO-8601 格式年份中的第几周，每周从星期一开始（PHP 4.1.0 新加的） 例如：42（当年的第 42 周）月 --- ---F 月份，完整的文本格式，例如 January 或者 March January 到 Decemberm 数字表示的月份，有前导零 01 到 12M 三个字母缩写表示的月份 Jan 到 Decn 数字表示的月份，没有前导零 1 到 12t 指定的月份有几天 28 到 31年 --- ---L 是否为闰年 如果是闰年为 1，否则为 0o ISO-8601 格式年份数字。这和 Y 的值相同，只除了如果 ISO 的星期数（W）属于前一年或下一年，则用那一年。（PHP 5.1.0 新加） Examples: 1999 or 2003Y 4 位数字完整表示的年份 例如：1999 或 2003y 2 位数字表示的年份 例如：99 或 03时间 --- ---a 小写的上午和下午值 am 或 pmA 大写的上午和下午值 AM 或 PMB Swatch Internet 标准时 000 到 999g 小时，12 小时格式，没有前导零 1 到 12G 小时，24 小时格式，没有前导零 0 到 23h 小时，12 小时格式，有前导零 01 到 12H 小时，24 小时格式，有前导零 00 到 23i 有前导零的分钟数 00 到 59&gt;s 秒数，有前导零 00 到 59&gt;u 毫秒 （PHP 5.2.2 新加）。需要注意的是 date() 函数总是返回 000000 因为它只接受 integer 参数， 而 DateTime::format() 才支持毫秒。 示例: 654321时区 --- ---e 时区标识（PHP 5.1.0 新加） 例如：UTC，GMT，Atlantic/AzoresI 是否为夏令时 如果是夏令时为 1，否则为 0O 与格林威治时间相差的小时数 例如：+0200P 与格林威治时间（GMT）的差别，小时和分钟之间有冒号分隔（PHP 5.1.3 新加） 例如：+02:00T 本机所在的时区 例如：EST，MDT（【译者注】在 Windows 下为完整文本格式，例如“Eastern Standard Time”，中文版会显示“中国标准时间”）。Z 时差偏移量的秒数。UTC 西边的时区偏移量总是负的，UTC 东边的时区偏移量总是正的。 -43200 到 43200完整的日期／时间 --- ---c ISO 8601 格式的日期（PHP 5 新加） 2004-02-12T15:19:21+00:00r RFC 822 格式的日期 例如：Thu, 21 Dec 2000 16:01:07 +0200U 从 Unix 纪元（January 1 1970 00:00:00 GMT）开始至今的秒数 参见 time() Carbon时间处理第三方库1Carbon::parse('2017-08-25 18:18:18'); # 不用指定格式即可将时间字符串自动转换为Carbon对象 文件操作12345678$fp = fopen("test", "r") or die("Unable to open file!"); # 打开文件$fp = fopen('test', 'w') # 写入fread($fp,filesize("webdictionary.txt")); # 读取指定大小的内容fgetc($fp) # 读取一个字符fgets($fp) # 读取一行feof($fp) # 判断指针是否指向文件尾了fwrite($fp, 'haofly') # 写入字符串到文件fclose($fp); # 关闭文件 函数/类/对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# public, private, projtected的区别:public # 权限最多，可以内部调用，实例调用protected # 受保护类型，用于本类和继承类调用private # 私有类型，只有在本类中使用 # 对象的序列化和反序列化serialize()unserialize() # 一些自省(反射)方法func_get_args() # 获取当前方法所有的参数get_class(className) # 取得当前语句所在的类名get_class_methods(className) # 取得相应class所包含的所有的方法名get_class_vars(clasName) # 取得相应class所包含的所有的变量名get_object_vars($object) # 获取类或者对象的属性，返回数组property_exists($object, $key) # 类或者对象是否存在某个属性setAttribute($name, $value) # 设置函数的属性或者直接设置函数的内部变量$this-&gt;&#123;$key&#125; = $value # 给类动态添加属性$this-&gt;&#123;$key&#125; # 返回对象指定的属性# 根据类名知道类的定义文件$reflector = new ReflectionClass('className');echo $reflector-&gt;getFileName();# 标准嘞StdClass$obj-&gt;value # 直接获取其内部的变量 # trait: 一种代码复用机制，从基类继承的成员会被trait插入的成员所覆盖，优先顺序是来自当前类的成员覆盖了trait的方法，而trait则覆盖了被继承的方法。这是为了弥补PHP单继承的局限# 例如可以写一个单例:trait SingleInstance&#123; static private $instance = null; static public function getInstance()&#123; if (!self::$instance) &#123; self::$instance = new static(); &#125; return self::$instance; &#125;&#125;# 在其他类里面只需要use SingleInstance就行了。再比如，文档里面的例子&lt;?phpclass Base &#123; public function sayHello() &#123; echo 'Hello '; &#125;&#125;trait SayWorld &#123; public function sayHello() &#123; parent::sayHello(); echo 'World!'; &#125;&#125;class MyHelloWorld extends Base &#123; use SayWorld;&#125;$o = new MyHelloWorld();$o-&gt;sayHello(); // 输出的是Hello World?&gt; 发送CURL请求注意：使用CURL之前一定要先确定服务器是否已经安装php的curl扩展，如果没有，可能会报奇怪的错误，安装完扩展后记得重启php进程。123456789101112131415161718192021$ch = curl_init(); // 初始化curlcurl_setopt(); // 设置参数curl_setopt($ch, CURLOPT_URL, 'url'); // 设置URLcurl_setop($ch, CURLOPT_POST, true); // 发送POST请求curl_setop($ch, CURL_POSTFIELDS, $data); // POST的数据curl_setop($ch, CURLOPT_RETURNTRANSFER, true); // 获取返回结果，如果不加这个，那么$result=true$result = curl_exec($ch); // 执行curl请求curl_getinfo($ch, CURLINFO_HTTP_CODE) // 获取http_code curl_setopt($curlHandle, CURLOPT_HTTPHEADER, ['Accept: application/json']); // 添加HTTP头curl_close($ch); // 关闭连接# 如果要通过CURL 上传文件，那么需要这样对$data进行处理if (function_exists('curl_file_create')) &#123; // php 5.6+ $cFile = curl_file_create($scriptPath);&#125; else &#123; // $cFile = '@' . realpath($scriptPath);&#125;$data = ['file' =&gt; $cFile];# 获取curl所有参数所代表的常量值$arr = get_defined_constants(true);var_dump($arr['curl']); WEB程序1234567891011$_SERVER['REQUEST_METHOD'] # 返回数据提交的方式，GET、POST等$_SERVER["SERVER_PORT"] # 获取端口$_SERVER['HTTP_HOST'] # 获取域名或主机地址$_SERVER['SERVER_NAME'] # 获取域名或主机名$_SERVER["REQUEST_URI"] # 获取域名后的详细地址$_SERVER['PHP_SELF'] # 获取PHP文件名$_SERVER["QUERY_STRING"] # 获取网址后的参数$_SERVER['HTTP_REFERER'] # 获取来源urlparse_str(file_get_contents("php://input"),$post_vars); # 获取PUT数据getallheaders # 获取请求头error_log('message') # 把错误信息发送到web服务器的错误日志，或者到一个文件里，有长度限制 MySQL1mysql_errno(): # 打印SQL出错信息 异常处理12345try&#123; throw new Exception('soahg');&#125;catch(Exception $e)&#123; echo $e-&gt;getMessage();&#125; PHP命令行1php --ini # 查看php的配置文件 帮助函数12345678910111213141516171819gettype(): 获取变量类型$obj instanceof A # 判断对象是否属于某个类，不过判断是不是数组只能用is_array() # 判断是否是数组is_string() # 判断是否是字符串is_object() # 判断是否是objectis_bool() # 是否是布尔值is_int() # 是否是整数is_integer()# 是否是整数is_float() # 是否是浮点数is_real() # 是否是实数is_numeric # 是否是数字或者数字字符串interface_exists() # 检查接口是否已经定义class_exists() # 检查类是否已经定义 PHP_INT_MAX # 最大整数PHP_INT_MIN # 最小整数min($value1, $value2...) # 选出最小值，最大值max同理min([$value1, $value2,...]) # 选出最小值，最大值max同理 hash_hmac(算法名, 明文, 盐) # hash加密函数，可以选定加密算法，例如hash_hmac('sha1', 'mingwen', 'salt') @操作符: 错误控制运算符，写在一行的前面，可以控制改行不输出warning信息或错误信息 var_dump(变量名)：打印变量，这个函数还会打印变量的类型可以把一个变量的各个部分全部信息输出，包括每个部分的数据类型和长度等信息，但是默认情况下，输出有限制，如果层数深了或者数据长了可能会表示成省略号，可以在C:\wamp\bin\apache\apache2.4.9\bin\php.ini里面修改xdebug节点，添加如下内容 12xdebug.var_display_max_data=512xdebug.var_display_max_depth=5 另外，将var_dump的输出转换为一个字符串以便web前端显示，可以这样用：12345ob_start();var_dump($data);$result = ob_get_clean();# 或者用另外的函数var_export: 输出或返回一个变量的字符串表示 file_get_contents：获取文件或http内容，如果要从http获得json数据可以直接使用它 isset()：查看某个变量是否已经被定义，未赋值或赋NULL都会返回false @header(‘Content-type: text/html;charset=UTF-8’);PHP文件中添加中文支持，在脚本开始的地方添加给行即可 多行输出：其中最后一个EOF必须写在一行的开头，且里面如果要用变量这样用{ $php_var }echo &lt;&lt;&lt;EOF print_r:打印关于变量的易于理解的信息。如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。这点在调试的时候很有用 类的方法尽量写成static，速度比public快 composer包管理require是指在生产环境中必须的包，而require-dev则是开发的时候要用而生产环境无需用的包，常用命令:123456789composer config --list # 列出当前所有的配置composer show # 获取所有安装的包的列表composer require package_name --dev # 安装包，并将其写入composer.json的require-dev中去composer remove package_name # 移除包composer config -g repo.packagist composer https://packagist.phpcomposer.com # 更换为国内的源# 忽略ssl证书验证composer config --global disable-tls truecomposer config --global secure-http false"package/ppkg": "2.7.*@beta" # 安装beta版 autoloadautoload，可以预加载类，自动索引所有的类，能够加快依赖的索引速度。但是autoload并不是实时更新的，如果发现vendor/composer/autoload_classmap.php中的类与你预想的有冲突，那么就需要更新一下了：composer dump-autoload。 在composer.json中有四种自动加载类型: classmap: development相关的 123&#123; "classmap": ["src/"] # 这样composer就会读取这个文件夹下所有的文件，然后再vendor/composer/autoload_classmap.php中将所有的class的namespace+classname生成一个key=&gt;value的数组&#125; psr-0: 已经被弃用 psr-4: 一般用于项目代码的自动加载 files: helper相关的Extension扩展管理12var_dump(extension_loaded('curl')); // 查看是否安装某个模块var_dump(get_loaded_extensions()); // 查看安装了哪些模块 TroubleShooting Call to undefined function getallheaders()版本问题，如果是老版本可以使用如下代码代替 12345678910111213if (!function_exists('getallheaders')) &#123; function getallheaders() &#123; foreach($_SERVER as $key=&gt;$value) &#123; if (substr($key,0,5)=="HTTP_") &#123; $key=str_replace(" ","-",ucwords(strtolower(str_replace("_"," ",substr($key,5))))); $out[$key]=$value; &#125;else&#123; $out[$key]=$value; &#125; &#125; return $out; &#125; &#125; 回掉函数中访问外部变量方法一：使用类的静态变量方法二：使用use语法 123$dt-&gt;each(function() use($bianliang) &#123; echo $bianliang;&#125;); Error while reading line from server这是在使用predis时报的错误，原因是没有设置read_write_timeout=－1使redis保持永久连接，否则会在一定时间后断开连接 isset和empty判断变量是否存在的问题。都不能用于静态数组变量的判断，最好用array_key_exists 原文摘至：http://haofly.net/php/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《维和步兵营》观后感]]></title>
    <url>%2F2017%2F11%2F23%2F%E3%80%8A%E7%BB%B4%E5%92%8C%E6%AD%A5%E5%85%B5%E8%90%A5%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[《维和步兵营》看完之后给我给我的感触和启发都颇深，脑子里久久都回荡着里面的每一个场景，不得不说是一部好的电视剧，从《士兵突击》到《我是特种兵》系列到《维和步兵营》不得不让我爱上那种军人气概、军人气节、军人情怀。天气转凉，蜷缩在被窝里，写点观后感，一部电视剧也是一种经历，记录下此刻的心境。 不是每个人生下来就拥有和平的生活，也不是每个人生下来就该面临残酷的社会境况。当我们在一个和平的国度每天上下班努力打拼赚钱养家，回家能洗上热乎乎的热水澡，晚上抱着媳妇儿孩子睡觉，工作之余出门旅游度假时，或者其他国家的人正在面临着战争、饥荒、疾病、死亡；我们生活在和平的国家，能谈理想、能享受生活，或许他们是否能活过明天都还是未知数。这不电视剧里面有很多都是真实的写照，部落之间的冲突与矛盾，政府军与反政府军的冲突，恐怖分子与资源争夺的冲突，这些都是真实发生在遥远的非洲，非洲人民面临战争、面临饥荒、面临贫穷与落后，里面有多个镜头是他们在马路浑浊的小水沟里取水的场景，看着着实辛酸；小孩们很多都是衣不遮体，很多的小孩和大人为了生活，不得不拿起手中的枪参加杀戮。 《维护步兵营》讲述的是一群训练有素的中国特种部队（隶属于中国特种部队红一连，红一连历史悠久、战功卓绝，跟随毛泽东参加过秋收起义，也称秋收起义红一连）奔赴非洲，维护世界和平的一段故事，在里面，我们看到了中国军人不畏艰难，有勇有谋，敢流血、敢牺牲的英勇精神；他们奔赴远方，头戴蓝盔，走向世界，维护和平。观影过程中不由自主留下四次泪水，有激动的泪水、感人的泪水、也有愤概的泪水，他们不是以个人、集团军的名义走向世界，他们是以国家荣誉而走向世界，13亿中国人是他们坚实的后盾，流血流泪，哪怕是牺牲，他们也只是默默的付出，不求回报。 人物描述 戈睿：参军前，一个耀武扬威的公子哥，仗着自己家里有点钱，不可一世，整天都在想给身边的人证明点什么，却什么也没能证明；参军之后，也是一个‘买一赠一’的货，随着机缘来到特种部队，并且进入到红一连的维护部队训练营，毕竟年轻，桀骜不顺，吃过苦头，但还是觉得自己了不起，成天与薛三桥斗嘴，去导非洲之后还与外国士兵为争夺郑百合大打出手；当然，行事正义，为人大方。对于他非常特别的转变应该在薛三桥死后，真正的成熟不少，沉稳、执着，特别是在他给她妈打电话的那一刻，我不忍热泪盈眶。 薛三桥：记忆最深刻的当然是他的口头禅：“我不是针对谁，我也不是挑事的人”，一直都是戈睿的死对头，每次听到他说这句话我都想笑，有了他和戈睿，军营多了很多的欢声笑语、军营氛围；在他被炸弹击中倒下的那一刻，我又重新理解了战友之间的情怀，哪怕不是薛三桥，有可能其他的人也上了，因为在我的理解下，那是一种本能的反应，谁都有可能冲上去，就在冲上去的那一刻，倒下就再也没起来，头上都炸了几个窟窿。 戈向东：商人、退伍军人，有着浓烈的军人情结，不管是在利比亚还是非洲，都为中国军人给予不少的帮助，在他看来军民早就是一家人，同时他的身影，也体现了中国人民对非洲人民作出的贡献与付出，不畏战争，不畏死亡，为世界和平事业奉献一份力量。 岳东明：从《我是特种兵》里面的身影一直到这部戏，给我的感觉都是一个特别刚直不阿、不折不扣的军人，他的言语很有气势也很能打动人，我相信不仅仅是演戏，生活中也是一个很受欢迎的人。他在剧中的角色可以说是一个关键人物，在两连队人重组之后几乎到了快散架的时候，是他的出现稳定了全局；在赵忠宝失意决心离开部队退伍的时候，是他的出现，重新燃起赵忠宝那股战斗热情；在林浩楠决心离开连长一职，走向司令部获取更多情报时，是他的出现，重新带领整个连队继续战斗。他的角色可以说文武双全，有战略思想，同时也有政治情怀，剧中最让他无助的是在他还在部落战争维和的时候，他的母亲却悄然离开了人世，相隔万里，那种思念之痛可想而知；在剧中后半部分的时候，他却因为保护几个孩子，被恐怖分子的火箭弹击中，从此永远离开了红一连。家里有老婆，还有两个孩子，面对这样的情况编剧是不是有点太残忍了。 罗汉：罗汉这个演员还是在《我是特种兵》里面认识的，帅气、冷酷的形象让人记忆尤新，在本剧里面扮演的是林浩楠的助手，参演过很多的电视剧，可能以后也不会是男一号，但是他的人物个性鲜明，演技到位，我现在看这种电视剧有个情结，凡是有特种兵里面的人物，我都会继续看下去。 田爽：饰演者孙晶晶，在里面是个不折不扣的大美女，身材火辣性感，在本剧中为戈向东在非洲企业中的得力经理。。。 未完待续。。。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
